<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D ストリングアート（正 N/M）</title>
  <style>
    :root{
      --bg:#0b0f17;
      --bg2:#111827;
      --fg:#e5e7eb;
      --muted:#9ca3af;

      --panel: rgba(17,24,39,.86);
      --border: rgba(255,255,255,.12);

      --btnBg: rgba(255,255,255,.06);
      --btnBgHover: rgba(255,255,255,.10);
      --btnBorder: rgba(255,255,255,.14);

      --inputBg: rgba(0,0,0,.25);

      /* テーマ切替 */
      --boxBg: rgba(0,0,0,.18);
      --controlsBg: linear-gradient(to bottom, rgba(17,24,39,1), rgba(17,24,39,.55));
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0; overflow:hidden;
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic",sans-serif;
      background: radial-gradient(1200px 700px at 30% 20%, var(--bg2), var(--bg));
      color:var(--fg);
    }

    .wrap{
      display:grid;
      grid-template-columns: 420px 1fr;
      height:100vh; width:100vw;
    }

    .panel{
      height:100vh; overflow:auto;
      padding:16px;
      background: var(--panel);
      border-right:1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(8px);
    }

    h1{ margin:0 0 10px; font-size:18px; }
    .desc{ color:var(--muted); font-size:12px; line-height:1.55; margin-bottom:12px; }

    .box{
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
      background: var(--boxBg);
      margin-bottom:12px;
    }

    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-bottom:10px;
    }

    .field{ display:flex; flex-direction:column; gap:6px; }
    .label{ font-size:11px; color:var(--muted); }

    input[type="number"], select{
      width:100%;
      padding:10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background: var(--inputBg);
      color:var(--fg);
      outline:none;
    }
    input[type="checkbox"]{ transform: scale(1.1); }
    input[type="color"]{
      width:100%; height:36px;
      border:none; background:transparent; padding:0;
    }

    .btns{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      justify-content:center; /* 中央寄せ */
      position: sticky; top:0; z-index:3;
      padding:10px 0;
      background: var(--controlsBg);
      border-bottom: 1px solid rgba(255,255,255,.06);
    }

    button{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--btnBorder);
      background: var(--btnBg);
      color:var(--fg);
      cursor:pointer;
      user-select:none;
    }
    button:hover{ background: var(--btnBgHover); }

    .btnPrimary{ border-color: rgba(96,165,250,.55); }
    .btnToggle{ border-color: rgba(52,211,153,.45); }
    .btnWarn{ border-color: rgba(251,191,36,.55); }

    .meta{
      font-size:12px; line-height:1.6;
      color: var(--muted);
    }
    .meta b{ color: var(--fg); }

    .viewer{
      position:relative;
      height:100vh;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
    }
    #stage{
      width:100%;
      height:100%;
      display:block;
      cursor:grab;
      touch-action: none;
    }
    #stage.dragging{ cursor:grabbing; }

    .hud{
      position:absolute;
      left:12px; top:12px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.18);
      color: rgba(255,255,255,.92);
      padding:10px 12px;
      border-radius:12px;
      font-size:12px;
      line-height:1.5;
      pointer-events:none;
      white-space:nowrap;
      max-width: 70vw;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .hud.light{
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(0,0,0,.18);
      color: rgba(17,24,39,.98);
    }

    .tiny{ font-size:11px; color:var(--muted); line-height:1.55; margin-top:8px; }
  </style>
</head>

<body>
<div class="wrap">
  <div class="panel">
    <h1>3D ストリングアート（正 N/M）</h1>
    <div class="desc">
      上面・底面の円周上に <b>N</b> 等分点（ピン）を置き，<b>始点0</b>から
      <b>+M (mod N)</b> で点を辿り，<b>始点に戻るまで</b> 1本の折れ線で結びます。<br/>
      フィルタ（偶数/奇数/剰余）で「使う点」を制限できます。合わない点は許可点へ <b>スナップ</b>します（最小構成）。
    </div>

    <div class="btns">
      <button id="btnApply" class="btnPrimary">反映</button>
      <button id="btnAnim" class="btnToggle">▶ アニメ再生</button>
      <button id="btnReset" class="btnWarn">リセット</button>
      <button id="btnShot">スクショ保存（PNG）</button>
    </div>

    <div class="box">
      <div class="row">
        <div class="field">
          <div class="label">N（分割数）</div>
          <!-- ★ デフォルトは未入力 -->
          <input id="inN" type="number" min="3" step="1" value="" placeholder="（未入力）" />
        </div>
        <div class="field">
          <div class="label">M（ステップ）</div>
          <!-- ★ デフォルトは未入力 -->
          <input id="inM" type="number" min="0" step="1" value="" placeholder="（未入力）" />
        </div>
      </div>

      <div class="row">
        <div class="field">
          <div class="label">半径 R</div>
          <input id="inR" type="number" min="0.1" step="0.1" value="3.0" />
        </div>
        <div class="field">
          <div class="label">高さ h</div>
          <input id="inH" type="number" min="0.1" step="0.1" value="4.0" />
        </div>
      </div>

      <div class="row">
        <div class="field">
          <div class="label">上面ピンの条件</div>
          <select id="selTop">
            <option value="all" selected>全て</option>
            <option value="even">偶数のみ</option>
            <option value="odd">奇数のみ</option>
            <option value="mod">mod k = r</option>
          </select>
        </div>
        <div class="field">
          <div class="label">底面ピンの条件</div>
          <select id="selBottom">
            <option value="all" selected>全て</option>
            <option value="even">偶数のみ</option>
            <option value="odd">奇数のみ</option>
            <option value="mod">mod k = r</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div class="field">
          <div class="label">上面：k（mod の法）</div>
          <input id="inTopK" type="number" min="2" step="1" value="2" />
        </div>
        <div class="field">
          <div class="label">上面：r（余り）</div>
          <input id="inTopR" type="number" min="0" step="1" value="0" />
        </div>
      </div>

      <div class="row">
        <div class="field">
          <div class="label">底面：k（mod の法）</div>
          <input id="inBotK" type="number" min="2" step="1" value="2" />
        </div>
        <div class="field">
          <div class="label">底面：r（余り）</div>
          <input id="inBotR" type="number" min="0" step="1" value="1" />
        </div>
      </div>

      <div class="row">
        <div class="field">
          <div class="label">糸の色</div>
          <input id="colLine" type="color" value="#60a5fa" />
        </div>
        <div class="field">
          <div class="label">ピンの色</div>
          <input id="colPin" type="color" value="#e5e7eb" />
        </div>
      </div>

      <div class="row">
        <div class="field">
          <div class="label">点番号を表示</div>
          <div style="display:flex; align-items:center; gap:10px; padding:6px 2px;">
            <input id="chkLabels" type="checkbox" />
            <span style="font-size:12px; color:var(--muted);">ON</span>
          </div>
        </div>
        <div class="field">
          <div class="label">点番号サイズ（px）</div>
          <input id="inLabelPx" type="number" min="10" step="1" value="22" />
        </div>
      </div>

      <div class="row">
        <div class="field">
          <div class="label">アニメ時間（秒）</div>
          <input id="inAnimT" type="number" min="0.2" step="0.1" value="7.0" />
        </div>
        <div class="field">
          <div class="label">テーマ</div>
          <select id="selTheme">
            <option value="dark" selected>ダーク</option>
            <option value="light">ライト</option>
          </select>
        </div>
      </div>

      <div class="tiny">
        操作：左ドラッグ=回転 / 右ドラッグ=パン / ホイール=ズーム（自前コントロール）<br/>
        ※円柱本体は表示せず、上面/底面の円ガイドだけ描きます。<br/>
        ※アニメは「ストローク（線が伸びる）」で描画します。
      </div>
    </div>

    <div class="box meta" id="meta"></div>
  </div>

  <div class="viewer">
    <canvas id="stage"></canvas>
    <div class="hud" id="hud">Three.js を読み込み中…</div>
  </div>
</div>

<script>
function loadScriptWithFallback(urls){
  return new Promise((resolve, reject) => {
    let i = 0;
    const tryNext = () => {
      if (i >= urls.length) { reject(new Error("All CDN failed: " + urls.join(" | "))); return; }
      const url = urls[i++];
      const s = document.createElement("script");
      s.src = url;
      s.async = true;
      s.onload = () => resolve(url);
      s.onerror = () => { s.remove(); tryNext(); };
      document.head.appendChild(s);
    };
    tryNext();
  });
}

window.addEventListener("load", async () => {
  const hud = document.getElementById("hud");
  try {
    hud.textContent = "Three.js を読み込み中…";
    const threeUrl = await loadScriptWithFallback([
      "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js",
      "https://unpkg.com/three@0.160.0/build/three.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"
    ]);
    startApp({ threeUrl });
  } catch (e) {
    hud.textContent = "起動失敗: CDNがブロックされている可能性があります（学校Wi-Fiなど）。";
    console.error(e);
  }
});

function startApp({ threeUrl }){
  const hud = document.getElementById("hud");

  // -----------------------------
  // Utilities
  // -----------------------------
  const TAU = Math.PI * 2;
  const mod = (n, m) => ((n % m) + m) % m;

  const gcd = (a, b) => {
    a = Math.abs(a); b = Math.abs(b);
    while (b !== 0) { const t = a % b; a = b; b = t; }
    return a;
  };

  function parseMaybeInt(str){
    const t = String(str ?? "").trim();
    if (t === "") return null;
    const v = Math.floor(Number(t));
    return Number.isFinite(v) ? v : null;
  }
  function clampInt(v, min, max){
    v = Math.floor(Number(v));
    if (!Number.isFinite(v)) return min;
    return Math.max(min, Math.min(max, v));
  }
  function clampNum(v, min, max){
    v = Number(v);
    if (!Number.isFinite(v)) return min;
    return Math.max(min, Math.min(max, v));
  }

  function makeFilter(kind, k, r){
    k = Math.max(2, Math.floor(Number(k) || 2));
    r = mod(Math.floor(Number(r) || 0), k);

    if (kind === "even") return (i)=> (i % 2 === 0);
    if (kind === "odd")  return (i)=> (i % 2 !== 0);
    if (kind === "mod")  return (i)=> (mod(i, k) === r);
    return (_)=> true;
  }

  function buildAllowedList(N, pred){
    const arr = [];
    for (let i=0;i<N;i++) if (pred(i)) arr.push(i);
    return arr;
  }

  function snapToAllowed(N, j, allowed){
    if (!allowed.length) return null;
    const jj = mod(j, N);
    let best = allowed[0];
    let bestD = Infinity;
    for (const a of allowed){
      const d = Math.min(mod(a - jj, N), mod(jj - a, N));
      if (d < bestD){ bestD = d; best = a; if (bestD === 0) break; }
    }
    return best;
  }

  // ★ 3D版：2D同様に「始点0→+M→…→始点に戻るまで」ノード列を作る
  function buildCycle3D(N, M, topAllowed, bottomAllowed){
    const step = mod(M, N);

    const topSet = new Set(topAllowed);
    const botSet = new Set(bottomAllowed);

    let start = 0;
    if (!topSet.has(start)) {
      const snapped = snapToAllowed(N, start, topAllowed);
      if (snapped == null) return { valid:false, nodes:[] };
      start = snapped;
    }

    const nodes = [{ side:"T", idx:start }];

    if (N <= 0 || step === 0){
      nodes.push({ side:"T", idx:start });
      return { valid:true, nodes };
    }

    let curSide = "T";
    let curIdx = start;

    const seen = new Set([`T:${start}`]);
    const maxSteps = 2 * N + 10;

    for (let t=0; t<maxSteps; t++){
      const nextSide = (curSide === "T") ? "B" : "T";
      const allow = (nextSide === "T") ? topAllowed : bottomAllowed;
      const allowSet = (nextSide === "T") ? topSet : botSet;

      const rawNext = mod(curIdx + step, N);
      const nextIdx = allowSet.has(rawNext) ? rawNext : snapToAllowed(N, rawNext, allow);
      if (nextIdx == null) break;

      nodes.push({ side: nextSide, idx: nextIdx });

      if (nextSide === "T" && nextIdx === start){
        return { valid:true, nodes };
      }

      const key = `${nextSide}:${nextIdx}`;
      if (seen.has(key)) break;
      seen.add(key);

      curSide = nextSide;
      curIdx = nextIdx;
    }

    return { valid:false, nodes };
  }

  // -----------------------------
  // DOM
  // -----------------------------
  const cv = document.getElementById("stage");
  const metaEl = document.getElementById("meta");

  const inN = document.getElementById("inN");
  const inM = document.getElementById("inM");
  const inR = document.getElementById("inR");
  const inH = document.getElementById("inH");
  const selTop = document.getElementById("selTop");
  const selBottom = document.getElementById("selBottom");
  const inTopK = document.getElementById("inTopK");
  const inTopR = document.getElementById("inTopR");
  const inBotK = document.getElementById("inBotK");
  const inBotR = document.getElementById("inBotR");
  const colLine = document.getElementById("colLine");
  const colPin = document.getElementById("colPin");
  const inAnimT = document.getElementById("inAnimT");
  const selTheme = document.getElementById("selTheme");
  const chkLabels = document.getElementById("chkLabels");
  const inLabelPx = document.getElementById("inLabelPx");

  const btnApply = document.getElementById("btnApply");
  const btnAnim = document.getElementById("btnAnim");
  const btnReset = document.getElementById("btnReset");
  const btnShot  = document.getElementById("btnShot");

  cv.addEventListener("contextmenu", (e)=>e.preventDefault());

  // -----------------------------
  // Three.js scene
  // -----------------------------
  const renderer = new THREE.WebGLRenderer({
    canvas: cv,
    antialias: true,
    alpha: true,
    preserveDrawingBuffer: true,
  });
  renderer.setPixelRatio(Math.min(2.5, window.devicePixelRatio || 1));

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(55, 1, 0.01, 500);

  scene.add(new THREE.AmbientLight(0xffffff, 0.60));
  const dir = new THREE.DirectionalLight(0xffffff, 0.90);
  dir.position.set(6, 10, 8);
  scene.add(dir);

  const root = new THREE.Group();
  scene.add(root);

  // -----------------------------
  // Theme
  // -----------------------------
  function applyTheme(theme){
    const rootStyle = document.documentElement.style;

    if (theme === "light"){
      rootStyle.setProperty("--bg", "#ffffff");
      rootStyle.setProperty("--bg2", "#ffffff");
      rootStyle.setProperty("--fg", "#111827");
      rootStyle.setProperty("--muted", "#374151");
      rootStyle.setProperty("--panel", "#ffffff");
      rootStyle.setProperty("--border", "rgba(0,0,0,.12)");
      rootStyle.setProperty("--btnBg", "#ffffff");
      rootStyle.setProperty("--btnBgHover", "rgba(0,0,0,.06)");
      rootStyle.setProperty("--btnBorder", "rgba(0,0,0,.25)");
      rootStyle.setProperty("--inputBg", "#ffffff");
      rootStyle.setProperty("--boxBg", "rgba(0,0,0,.03)");
      rootStyle.setProperty("--controlsBg", "linear-gradient(to bottom, rgba(255,255,255,1), rgba(255,255,255,.65))");

      hud.classList.add("light");
      scene.background = new THREE.Color("#ffffff");
    } else {
      rootStyle.setProperty("--bg", "#0b0f17");
      rootStyle.setProperty("--bg2", "#111827");
      rootStyle.setProperty("--fg", "#e5e7eb");
      rootStyle.setProperty("--muted", "#9ca3af");
      rootStyle.setProperty("--panel", "rgba(17,24,39,.86)");
      rootStyle.setProperty("--border", "rgba(255,255,255,.12)");
      rootStyle.setProperty("--btnBg", "rgba(255,255,255,.06)");
      rootStyle.setProperty("--btnBgHover", "rgba(255,255,255,.10)");
      rootStyle.setProperty("--btnBorder", "rgba(255,255,255,.14)");
      rootStyle.setProperty("--inputBg", "rgba(0,0,0,.25)");
      rootStyle.setProperty("--boxBg", "rgba(0,0,0,.18)");
      rootStyle.setProperty("--controlsBg", "linear-gradient(to bottom, rgba(17,24,39,1), rgba(17,24,39,.55))");

      hud.classList.remove("light");
      scene.background = new THREE.Color("#0b0f17");
    }
  }

  function getLabelPalette(){
    if (selTheme.value === "light") {
      return { fill: "rgba(17,24,39,0.96)", stroke: "rgba(255,255,255,0.92)" };
    }
    return { fill: "rgba(255,255,255,0.92)", stroke: "rgba(0,0,0,0.78)" };
  }

  // -----------------------------
  // Manual camera control
  // -----------------------------
  const view = {
    target: new THREE.Vector3(0,0,0),
    dist: 12,
    yaw: 0.9,
    pitch: 0.55,
    minDist: 2.0,
    maxDist: 80.0,
    minPitch: -1.45,
    maxPitch:  1.45
  };

  function updateCamera(){
    const cp = Math.cos(view.pitch);
    const sp = Math.sin(view.pitch);
    const cy = Math.cos(view.yaw);
    const sy = Math.sin(view.yaw);

    const x = view.target.x + view.dist * cp * cy;
    const y = view.target.y + view.dist * sp;
    const z = view.target.z + view.dist * cp * sy;

    camera.position.set(x,y,z);
    camera.lookAt(view.target);
    camera.updateProjectionMatrix();
  }

  function resetViewToFit(R,H){
    const bound = Math.sqrt(R*R + (H*0.5)*(H*0.5));
    view.dist = Math.max(3, bound * 3.0);
    view.target.set(0,0,0);
    view.yaw = 0.9;
    view.pitch = 0.55;
    updateCamera();
  }

  function panScale(){
    return view.dist * 0.0012;
  }

  let dragging = false;
  let dragButton = 0;
  let lastX = 0, lastY = 0;

  cv.addEventListener("pointerdown", (e)=>{
    dragging = true;
    dragButton = e.button;
    lastX = e.clientX;
    lastY = e.clientY;
    cv.classList.add("dragging");
    cv.setPointerCapture(e.pointerId);
  });

  cv.addEventListener("pointerup", (e)=>{
    dragging = false;
    cv.classList.remove("dragging");
    try{ cv.releasePointerCapture(e.pointerId); }catch(_){}
  });

  cv.addEventListener("pointermove", (e)=>{
    if (!dragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;

    if (dragButton === 2) {
      const s = panScale();
      const forward = new THREE.Vector3().subVectors(view.target, camera.position).normalize();
      const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
      const up = new THREE.Vector3().crossVectors(right, forward).normalize();

      view.target.addScaledVector(right, -dx * s);
      view.target.addScaledVector(up,   dy * s);
      updateCamera();
    } else {
      view.yaw   -= dx * 0.006;
      view.pitch -= dy * 0.006;
      view.pitch = Math.max(view.minPitch, Math.min(view.maxPitch, view.pitch));
      updateCamera();
    }
  });

  cv.addEventListener("wheel", (e)=>{
    e.preventDefault();
    const factor = Math.exp(e.deltaY * 0.0012);
    view.dist *= factor;
    view.dist = Math.max(view.minDist, Math.min(view.maxDist, view.dist));
    updateCamera();
  }, { passive:false });

  // -----------------------------
  // Build helpers
  // -----------------------------
  function disposeObject(obj){
    obj.traverse((x)=>{
      if (x.geometry) x.geometry.dispose();
      if (x.material){
        if (Array.isArray(x.material)) x.material.forEach(m=>m.dispose());
        else x.material.dispose();
      }
      if (x.userData?._labelTexture) x.userData._labelTexture.dispose?.();
      if (x.material?.map) x.material.map.dispose?.();
    });
  }

  function clearRoot(){
    while (root.children.length){
      const obj = root.children.pop();
      disposeObject(obj);
    }
  }

  function buildGuideRings(R, H){
    const isLight = selTheme.value === "light";
    const ringMatTop = new THREE.LineBasicMaterial({ color: 0x111827, transparent:true, opacity: isLight ? 0.18 : 0.20 });
    const ringMatBot = new THREE.LineBasicMaterial({ color: 0x111827, transparent:true, opacity: isLight ? 0.12 : 0.14 });

    const seg = 180;

    function ring(z, mat){
      const pts = [];
      for (let k=0;k<=seg;k++){
        const a = TAU * (k/seg);
        pts.push(R*Math.cos(a), R*Math.sin(a), z);
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.Float32BufferAttribute(pts, 3));
      return new THREE.Line(geo, mat);
    }

    if (!isLight){
      ringMatTop.color = new THREE.Color(0xffffff);
      ringMatBot.color = new THREE.Color(0xffffff);
    }

    root.add(ring(+H/2, ringMatTop));
    root.add(ring(-H/2, ringMatBot));
  }

  function makeLabelSprite(text, fontPx, fill, stroke){
    const size = 256;
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const c = canvas.getContext("2d");

    c.clearRect(0,0,size,size);

    c.font = `700 ${fontPx}px system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif`;
    c.textAlign = "center";
    c.textBaseline = "middle";

    c.lineJoin = "round";
    c.lineWidth = Math.max(6, fontPx * 0.28);
    c.strokeStyle = stroke;
    c.strokeText(text, size/2, size/2);

    c.fillStyle = fill;
    c.fillText(text, size/2, size/2);

    const tex = new THREE.CanvasTexture(canvas);
    tex.anisotropy = 4;
    tex.needsUpdate = true;

    const mat = new THREE.SpriteMaterial({
      map: tex,
      transparent: true,
      depthWrite: false,
      depthTest: true
    });

    const spr = new THREE.Sprite(mat);
    spr.userData._labelTexture = tex;
    return spr;
  }

  function buildPins(N, R, z, pinColorHex, pred, showLabels, labelPx){
    const allowed = buildAllowedList(N, pred);

    const g = new THREE.SphereGeometry(Math.max(0.03, R*0.02), 16, 16);
    const m = new THREE.MeshStandardMaterial({
      color: new THREE.Color(pinColorHex),
      roughness: 0.25,
      metalness: 0.05
    });

    const group = new THREE.Group();
    const labelGroup = new THREE.Group();

    const { fill, stroke } = getLabelPalette();
    const fontPx = Math.max(14, Math.min(120, Number(labelPx) || 22));
    const worldLabelSize = Math.max(0.16, R * 0.12);

    for (let i=0;i<N;i++){
      if (!pred(i)) continue;

      const ang = TAU * (i / N) - Math.PI/2;
      const x = R * Math.cos(ang);
      const y = R * Math.sin(ang);

      const s = new THREE.Mesh(g, m);
      s.position.set(x, y, z);
      group.add(s);

      if (showLabels){
        const spr = makeLabelSprite(String(i), fontPx, fill, stroke);

        const len = Math.hypot(x,y) || 1;
        const nx = x / len;
        const ny = y / len;
        const off = Math.max(0.22, R * 0.10);

        spr.position.set(x + nx*off, y + ny*off, z);
        spr.scale.set(worldLabelSize, worldLabelSize, 1);

        labelGroup.add(spr);
      }
    }

    root.add(group);
    if (showLabels) root.add(labelGroup);

    return { allowed };
  }

  // -----------------------------
  // ★ 一本の折れ線（THREE.Line） + ストロークアニメ
  // -----------------------------
  let pathLine = null;
  let pathTotalEdges = 0;
  let pathBasePos = null;

  function buildPathLineFromCycle(N, R, H, nodes, lineColor){
    const zTop = +H/2;
    const zBot = -H/2;

    const pts = [];
    for (const nd of nodes){
      const ang = TAU * (nd.idx / N) - Math.PI/2;
      const x = R * Math.cos(ang);
      const y = R * Math.sin(ang);
      const z = (nd.side === "T") ? zTop : zBot;
      pts.push(x, y, z);
    }

    pathTotalEdges = Math.max(0, nodes.length - 1);

    const arr = new Float32Array(pts);
    pathBasePos = new Float32Array(arr);

    const geo = new THREE.BufferGeometry();
    geo.setAttribute("position", new THREE.Float32BufferAttribute(arr, 3));
    geo.setDrawRange(0, 0); // 最初は何も描かない

    const mat = new THREE.LineBasicMaterial({
      color: new THREE.Color(lineColor),
      transparent: true,
      opacity: 0.95,
    });

    pathLine = new THREE.Line(geo, mat);
    root.add(pathLine);
  }

  // ★ p(0..1) を「何本の辺まで」に変換して、最後の辺は補間で伸ばす
  function setLineProgress(p){
    if (!pathLine || !pathBasePos) return;

    const geo = pathLine.geometry;
    const posAttr = geo.getAttribute("position");
    const pos = posAttr.array;

    const t = Math.max(0, Math.min(1, p)) * pathTotalEdges;
    const whole = Math.floor(t);
    const frac = t - whole;

    if (pathTotalEdges <= 0){
      geo.setDrawRange(0, 0);
      return;
    }

    if (whole < pathTotalEdges && frac > 0){
      const visibleVerts = (whole + 2);
      geo.setDrawRange(0, visibleVerts);

      const aIdx = whole;
      const bIdx = whole + 1;

      const ax = pathBasePos[aIdx*3+0], ay = pathBasePos[aIdx*3+1], az = pathBasePos[aIdx*3+2];
      const bx = pathBasePos[bIdx*3+0], by = pathBasePos[bIdx*3+1], bz = pathBasePos[bIdx*3+2];

      pos[bIdx*3+0] = ax + (bx-ax)*frac;
      pos[bIdx*3+1] = ay + (by-ay)*frac;
      pos[bIdx*3+2] = az + (bz-az)*frac;

      posAttr.needsUpdate = true;
      return;
    }

    const visibleVerts = (whole + 1);
    geo.setDrawRange(0, visibleVerts);

    if (visibleVerts >= 1){
      const last = (visibleVerts - 1);
      pos[last*3+0] = pathBasePos[last*3+0];
      pos[last*3+1] = pathBasePos[last*3+1];
      pos[last*3+2] = pathBasePos[last*3+2];
      posAttr.needsUpdate = true;
    }
  }

  // -----------------------------
  // App / UI
  // -----------------------------
  let isPlaying = false;
  let startTime = 0;
  let animDuration = 7.0;

  function updateMetaUI(html){
    metaEl.innerHTML = html;
  }

  function showWaitingUI(){
    clearRoot();
    pathLine = null;
    pathTotalEdges = 0;
    pathBasePos = null;

    hud.textContent = "N と M を入力して「反映」を押してください。";
    updateMetaUI(`
      <div><b>待機中</b>: N/M が未入力です</div>
      <div style="margin-top:6px; opacity:.85;">THREE: ${threeUrl}</div>
    `);

    resetViewToFit(3.0, 4.0);
    isPlaying = false;
    btnAnim.textContent = "▶ アニメ再生";
  }

  function rebuild({ doFit = true } = {}){
    const Nraw = parseMaybeInt(inN.value);
    const Mraw = parseMaybeInt(inM.value);

    applyTheme(selTheme.value);

    if (Nraw == null || Mraw == null){
      showWaitingUI();
      return;
    }

    const N = clampInt(Nraw, 3, 2000);
    const M = clampInt(Mraw, 0, 2000000);
    const R = clampNum(inR.value, 0.1, 50);
    const H = clampNum(inH.value, 0.1, 80);

    const topKind = selTop.value;
    const botKind = selBottom.value;

    const topK = clampInt(inTopK.value, 2, 2000);
    const topR = clampInt(inTopR.value, 0, 2000000);
    const botK = clampInt(inBotK.value, 2, 2000);
    const botR = clampInt(inBotR.value, 0, 2000000);

    const lineColor = colLine.value;
    const pinColor  = colPin.value;

    animDuration = clampNum(inAnimT.value, 0.2, 120);

    const showLabels = chkLabels.checked;
    const labelPx = clampInt(inLabelPx.value, 10, 180);

    clearRoot();
    pathLine = null;
    pathTotalEdges = 0;
    pathBasePos = null;

    buildGuideRings(R, H);

    const topPred = makeFilter(topKind, topK, topR);
    const botPred = makeFilter(botKind, botK, botR);

    const topPins = buildPins(N, R, +H/2, pinColor, topPred, showLabels, labelPx);
    const botPins = buildPins(N, R, -H/2, pinColor, botPred, showLabels, labelPx);

    // ★ 2D同様の「巡回」(始点0→…→始点に戻る)
    const cyc = buildCycle3D(N, M, topPins.allowed, botPins.allowed);
    if (!cyc.valid || cyc.nodes.length < 2){
      hud.textContent = "フィルタが強すぎて始点に戻れません（条件を緩めてください）";
      updateMetaUI(`<div><b>無効</b>: 始点に戻る巡回が作れません</div>`);
      return;
    }

    buildPathLineFromCycle(N, R, H, cyc.nodes, lineColor);

    const step = mod(M, N);
    const d = gcd(N, step);
    const L = (step===0) ? 0 : (N/d);

    hud.textContent = `N=${N}, M=${M}（step=${step}） / 上:${topKind} 下:${botKind}`;
    updateMetaUI(`
      <div><b>N</b>=${N}, <b>M</b>=${M}, <b>step</b>=${step}</div>
      <div><b>gcd(N,step)</b>=${d} / <b>L</b>=${L}</div>
      <div>上面許可: <b>${topPins.allowed.length}</b> / 底面許可: <b>${botPins.allowed.length}</b></div>
      <div>折れ線の辺数: <b>${pathTotalEdges}</b></div>
      <div>点番号: <b>${showLabels ? "ON" : "OFF"}</b></div>
      <div style="margin-top:6px; opacity:.85;">THREE: ${threeUrl} / 操作: manual</div>
    `);

    isPlaying = false;
    btnAnim.textContent = "▶ アニメ再生";
    setLineProgress(1.0);

    if (doFit) resetViewToFit(R, H);
  }

  // -----------------------------
  // Resize & loop
  // -----------------------------
  function resize(){
    const w = cv.clientWidth;
    const h = cv.clientHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    updateCamera();
  }

  function loop(t){
    requestAnimationFrame(loop);

    if (isPlaying && pathLine){
      const elapsed = (t - startTime) / 1000;
      const p = Math.min(1, elapsed / animDuration);
      setLineProgress(p);
      if (p >= 1){
        isPlaying = false;
        btnAnim.textContent = "▶ アニメ再生";
      }
    }
    renderer.render(scene, camera);
  }

  function savePNG(){
    if (pathLine) setLineProgress(1.0);
    renderer.render(scene, camera);
    const url = renderer.domElement.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = url;
    a.download = "3d-string-art.png";
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  // -----------------------------
  // Events
  // -----------------------------
  btnApply.addEventListener("click", () => rebuild({ doFit:true }));

  btnAnim.addEventListener("click", ()=>{
    if (!pathLine) return;
    isPlaying = !isPlaying;
    if (isPlaying){
      startTime = performance.now();
      setLineProgress(0.0);
      btnAnim.textContent = "⏸ アニメ停止";
    } else {
      btnAnim.textContent = "▶ アニメ再生";
    }
  });

  // ★ リセットで N/M も未入力に戻す
  btnReset.addEventListener("click", ()=>{
    inN.value=""; inM.value="";
    inR.value="3.0"; inH.value="4.0";
    selTop.value="all"; selBottom.value="all";
    inTopK.value="2"; inTopR.value="0";
    inBotK.value="2"; inBotR.value="1";
    colLine.value="#60a5fa";
    colPin.value="#e5e7eb";
    chkLabels.checked = false;
    inLabelPx.value="22";
    inAnimT.value="7.0";
    selTheme.value="dark";
    rebuild({ doFit:true });
  });

  btnShot.addEventListener("click", savePNG);

  selTheme.addEventListener("change", ()=> rebuild({ doFit:false }));
  chkLabels.addEventListener("change", ()=> rebuild({ doFit:false }));
  inLabelPx.addEventListener("change", ()=> rebuild({ doFit:false }));
  colPin.addEventListener("input", ()=> rebuild({ doFit:false }));
  colLine.addEventListener("input", ()=> rebuild({ doFit:false }));
  selTop.addEventListener("change", ()=> rebuild({ doFit:false }));
  selBottom.addEventListener("change", ()=> rebuild({ doFit:false }));
  inTopK.addEventListener("change", ()=> rebuild({ doFit:false }));
  inTopR.addEventListener("change", ()=> rebuild({ doFit:false }));
  inBotK.addEventListener("change", ()=> rebuild({ doFit:false }));
  inBotR.addEventListener("change", ()=> rebuild({ doFit:false }));
  inR.addEventListener("change", ()=> rebuild({ doFit:true }));
  inH.addEventListener("change", ()=> rebuild({ doFit:true }));

  window.addEventListener("resize", resize);

  // -----------------------------
  // Boot
  // -----------------------------
  applyTheme(selTheme.value);
  resize();
  rebuild({ doFit:true });
  requestAnimationFrame(loop);
}
</script>
</body>
</html>
