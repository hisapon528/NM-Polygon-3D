<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D ストリングアート（正 N/M・円柱ガイド）</title>
  <style>
    :root{
      --bg:#0b0f17;
      --bg2:#111827;
      --fg:#e5e7eb;
      --muted:#9ca3af;
      --panel: rgba(17,24,39,.86);
      --border: rgba(255,255,255,.12);
      --btnBg: rgba(255,255,255,.06);
      --btnBgHover: rgba(255,255,255,.10);
      --btnBorder: rgba(255,255,255,.14);
      --inputBg: rgba(0,0,0,.25);
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0; overflow:hidden;
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic",sans-serif;
      background: radial-gradient(1200px 700px at 30% 20%, var(--bg2), var(--bg));
      color:var(--fg);
    }
    .wrap{
      display:grid;
      grid-template-columns: 420px 1fr;
      height:100vh; width:100vw;
    }
    .panel{
      height:100vh; overflow:auto;
      padding:16px;
      background: var(--panel);
      border-right:1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(8px);
    }
    h1{ margin:0 0 10px; font-size:18px; }
    .desc{ color:var(--muted); font-size:12px; line-height:1.55; margin-bottom:12px; }
    .box{
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
      background: rgba(0,0,0,.18);
      margin-bottom:12px;
    }
    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-bottom:10px;
    }
    .field{ display:flex; flex-direction:column; gap:6px; }
    .label{ font-size:11px; color:var(--muted); }
    input[type="number"], select{
      width:100%;
      padding:10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background: var(--inputBg);
      color:var(--fg);
      outline:none;
    }
    input[type="range"]{ width:100%; }
    input[type="color"]{
      width:100%; height:36px;
      border:none; background:transparent; padding:0;
    }
    .btns{
      display:flex; flex-wrap:wrap; gap:10px;
      position: sticky; top:0; z-index:3;
      padding:10px 0;
      background: linear-gradient(to bottom, rgba(17,24,39,1), rgba(17,24,39,.55));
      border-bottom: 1px solid rgba(255,255,255,.06);
    }
    button{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--btnBorder);
      background: var(--btnBg);
      color:var(--fg);
      cursor:pointer;
      user-select:none;
    }
    button:hover{ background: var(--btnBgHover); }
    .btnPrimary{ border-color: rgba(96,165,250,.55); }
    .btnToggle{ border-color: rgba(52,211,153,.45); }
    .btnWarn{ border-color: rgba(251,191,36,.55); }

    .meta{
      font-size:12px; line-height:1.6;
      color: var(--muted);
    }
    .meta b{ color: var(--fg); }

    .viewer{
      position:relative;
      height:100vh;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
    }
    #stage{
      width:100%;
      height:100%;
      display:block;
      cursor:grab;
      touch-action: none; /* wheel/touchを奪われにくくする */
    }
    #stage.dragging{ cursor:grabbing; }

    .hud{
      position:absolute;
      left:12px; top:12px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.18);
      color: rgba(255,255,255,.92);
      padding:10px 12px;
      border-radius:12px;
      font-size:12px;
      line-height:1.5;
      pointer-events:none;
      white-space:nowrap;
      max-width: 70vw;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .hud.light{
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(0,0,0,.18);
      color: rgba(17,24,39,.98);
    }
    .tiny{ font-size:11px; color:var(--muted); line-height:1.55; margin-top:8px; }
  </style>
</head>

<body>
<div class="wrap">
  <div class="panel">
    <h1>3D ストリングアート（正 N/M）</h1>
    <div class="desc">
      上面・底面の円周上に <b>N</b> 等分点（ピン）を置き，上面の点 <b>i</b> から底面の点 <b>f(i)</b> へ糸（線）を張ります。<br/>
      基本は <b>f(i)=i+M (mod N)</b>。フィルタ（偶数/奇数/剰余）で「使う点」を制限できます。<br/>
      フィルタに合わないときは <b>スナップ</b>で許可点へ寄せます（最小構成の仕様）。
    </div>

    <div class="btns">
      <button id="btnApply" class="btnPrimary">反映</button>
      <button id="btnAnim" class="btnToggle">▶ アニメ再生</button>
      <button id="btnReset" class="btnWarn">リセット</button>
      <button id="btnShot">スクショ保存（PNG）</button>
    </div>

    <div class="box">
      <div class="row">
        <div class="field">
          <div class="label">N（分割数）</div>
          <input id="inN" type="number" min="3" step="1" value="30" />
        </div>
        <div class="field">
          <div class="label">M（ステップ）</div>
          <input id="inM" type="number" min="0" step="1" value="3" />
        </div>
      </div>

      <div class="row">
        <div class="field">
          <div class="label">半径 R</div>
          <input id="inR" type="number" min="0.1" step="0.1" value="3.0" />
        </div>
        <div class="field">
          <div class="label">高さ h</div>
          <input id="inH" type="number" min="0.1" step="0.1" value="4.0" />
        </div>
      </div>

      <div class="row">
        <div class="field">
          <div class="label">上面ピンの条件</div>
          <select id="selTop">
            <option value="all">全て</option>
            <option value="even" selected>偶数のみ</option>
            <option value="odd">奇数のみ</option>
            <option value="mod">mod k = r</option>
          </select>
        </div>
        <div class="field">
          <div class="label">底面ピンの条件</div>
          <select id="selBottom">
            <option value="all">全て</option>
            <option value="even">偶数のみ</option>
            <option value="odd" selected>奇数のみ</option>
            <option value="mod">mod k = r</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div class="field">
          <div class="label">上面：k（mod の法）</div>
          <input id="inTopK" type="number" min="2" step="1" value="2" />
        </div>
        <div class="field">
          <div class="label">上面：r（余り）</div>
          <input id="inTopR" type="number" min="0" step="1" value="0" />
        </div>
      </div>

      <div class="row">
        <div class="field">
          <div class="label">底面：k（mod の法）</div>
          <input id="inBotK" type="number" min="2" step="1" value="2" />
        </div>
        <div class="field">
          <div class="label">底面：r（余り）</div>
          <input id="inBotR" type="number" min="0" step="1" value="1" />
        </div>
      </div>

      <div class="row">
        <div class="field">
          <div class="label">糸の色</div>
          <input id="colLine" type="color" value="#60a5fa" />
        </div>
        <div class="field">
          <div class="label">ピンの色</div>
          <input id="colPin" type="color" value="#e5e7eb" />
        </div>
      </div>

      <div class="row">
        <div class="field">
          <div class="label">アニメ時間（秒）</div>
          <input id="inAnimT" type="number" min="0.2" step="0.1" value="7.0" />
        </div>
        <div class="field">
          <div class="label">テーマ</div>
          <select id="selTheme">
            <option value="dark" selected>ダーク</option>
            <option value="light">ライト</option>
          </select>
        </div>
      </div>

      <div class="tiny">
        操作：左ドラッグ=回転 / 右ドラッグ=パン / ホイール=ズーム（OrbitControls不要）<br/>
        ※円柱本体は表示せず、上面/底面の円ガイドだけ描きます。
      </div>
    </div>

    <div class="box meta" id="meta"></div>
  </div>

  <div class="viewer">
    <canvas id="stage"></canvas>
    <div class="hud" id="hud">Three.js を読み込み中…</div>
  </div>
</div>

<script>
function loadScriptWithFallback(urls){
  return new Promise((resolve, reject) => {
    let i = 0;
    const tryNext = () => {
      if (i >= urls.length) { reject(new Error("All CDN failed: " + urls.join(" | "))); return; }
      const url = urls[i++];
      const s = document.createElement("script");
      s.src = url;
      s.async = true;
      s.onload = () => resolve(url);
      s.onerror = () => { s.remove(); tryNext(); };
      document.head.appendChild(s);
    };
    tryNext();
  });
}

window.addEventListener("load", async () => {
  const hud = document.getElementById("hud");
  try {
    hud.textContent = "Three.js を読み込み中…";
    const threeUrl = await loadScriptWithFallback([
      "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js",
      "https://unpkg.com/three@0.160.0/build/three.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"
    ]);
    startApp({ threeUrl });
  } catch (e) {
    hud.textContent = "起動失敗: CDNがブロックされている可能性があります（学校Wi-Fiなど）。";
    console.error(e);
  }
});

function startApp({ threeUrl }){
  const hud = document.getElementById("hud");

  // -----------------------------
  // Utilities
  // -----------------------------
  const TAU = Math.PI * 2;
  const mod = (n, m) => ((n % m) + m) % m;

  const gcd = (a, b) => {
    a = Math.abs(a); b = Math.abs(b);
    while (b !== 0) { const t = a % b; a = b; b = t; }
    return a;
  };

  function clampInt(v, min, max){
    v = Math.floor(Number(v));
    if (!Number.isFinite(v)) return min;
    return Math.max(min, Math.min(max, v));
  }
  function clampNum(v, min, max){
    v = Number(v);
    if (!Number.isFinite(v)) return min;
    return Math.max(min, Math.min(max, v));
  }

  function makeFilter(kind, k, r){
    k = Math.max(2, Math.floor(Number(k) || 2));
    r = mod(Math.floor(Number(r) || 0), k);

    if (kind === "even") return (i)=> (i % 2 === 0);
    if (kind === "odd")  return (i)=> (i % 2 !== 0);
    if (kind === "mod")  return (i)=> (mod(i, k) === r);
    return (_)=> true;
  }

  function buildAllowedList(N, pred){
    const arr = [];
    for (let i=0;i<N;i++) if (pred(i)) arr.push(i);
    return arr;
  }

  function snapToAllowed(N, j, allowed){
    if (!allowed.length) return null;
    const jj = mod(j, N);
    let best = allowed[0];
    let bestD = Infinity;
    for (const a of allowed){
      const d = Math.min(mod(a - jj, N), mod(jj - a, N));
      if (d < bestD){ bestD = d; best = a; if (bestD === 0) break; }
    }
    return best;
  }

  // -----------------------------
  // DOM
  // -----------------------------
  const cv = document.getElementById("stage");
  const metaEl = document.getElementById("meta");

  const inN = document.getElementById("inN");
  const inM = document.getElementById("inM");
  const inR = document.getElementById("inR");
  const inH = document.getElementById("inH");
  const selTop = document.getElementById("selTop");
  const selBottom = document.getElementById("selBottom");
  const inTopK = document.getElementById("inTopK");
  const inTopR = document.getElementById("inTopR");
  const inBotK = document.getElementById("inBotK");
  const inBotR = document.getElementById("inBotR");
  const colLine = document.getElementById("colLine");
  const colPin = document.getElementById("colPin");
  const inAnimT = document.getElementById("inAnimT");
  const selTheme = document.getElementById("selTheme");

  const btnApply = document.getElementById("btnApply");
  const btnAnim = document.getElementById("btnAnim");
  const btnReset = document.getElementById("btnReset");
  const btnShot  = document.getElementById("btnShot");

  // 右クリックメニューでパンが邪魔されるのを防ぐ
  cv.addEventListener("contextmenu", (e)=>e.preventDefault());

  // -----------------------------
  // Three.js scene
  // -----------------------------
  const renderer = new THREE.WebGLRenderer({
    canvas: cv,
    antialias: true,
    alpha: true,
    preserveDrawingBuffer: true,
  });
  renderer.setPixelRatio(Math.min(2.5, window.devicePixelRatio || 1));

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(55, 1, 0.01, 500);

  scene.add(new THREE.AmbientLight(0xffffff, 0.60));
  const dir = new THREE.DirectionalLight(0xffffff, 0.90);
  dir.position.set(6, 10, 8);
  scene.add(dir);

  // 描画対象は root にまとめて、回転は root を回す
  const root = new THREE.Group();
  scene.add(root);

  // -----------------------------
  // Theme
  // -----------------------------
  function applyTheme(theme){
    if (theme === "light"){
      document.documentElement.style.setProperty("--bg", "#ffffff");
      document.documentElement.style.setProperty("--bg2", "#ffffff");
      document.documentElement.style.setProperty("--fg", "#111827");
      document.documentElement.style.setProperty("--muted", "#374151");
      document.documentElement.style.setProperty("--panel", "#ffffff");
      document.documentElement.style.setProperty("--border", "rgba(0,0,0,.12)");
      document.documentElement.style.setProperty("--btnBg", "#ffffff");
      document.documentElement.style.setProperty("--btnBgHover", "rgba(0,0,0,.06)");
      document.documentElement.style.setProperty("--btnBorder", "rgba(0,0,0,.25)");
      document.documentElement.style.setProperty("--inputBg", "#ffffff");
      hud.classList.add("light");
      scene.background = new THREE.Color("#ffffff");
    } else {
      document.documentElement.style.setProperty("--bg", "#0b0f17");
      document.documentElement.style.setProperty("--bg2", "#111827");
      document.documentElement.style.setProperty("--fg", "#e5e7eb");
      document.documentElement.style.setProperty("--muted", "#9ca3af");
      document.documentElement.style.setProperty("--panel", "rgba(17,24,39,.86)");
      document.documentElement.style.setProperty("--border", "rgba(255,255,255,.12)");
      document.documentElement.style.setProperty("--btnBg", "rgba(255,255,255,.06)");
      document.documentElement.style.setProperty("--btnBgHover", "rgba(255,255,255,.10)");
      document.documentElement.style.setProperty("--btnBorder", "rgba(255,255,255,.14)");
      document.documentElement.style.setProperty("--inputBg", "rgba(0,0,0,.25)");
      hud.classList.remove("light");
      scene.background = new THREE.Color("#0b0f17");
    }
  }

  // -----------------------------
  // Manual camera control (確実に動く：回転/パン/ズーム)
  // -----------------------------
  const view = {
    // “見る中心（パンで動く）”
    target: new THREE.Vector3(0,0,0),

    // カメラ距離（ズーム）
    dist: 12,

    // 回転（ラジアン）
    yaw: 0.9,
    pitch: 0.55,

    // 制限
    minDist: 2.0,
    maxDist: 80.0,
    minPitch: -1.45,
    maxPitch:  1.45
  };

  function updateCamera(){
    // 球座標→直交座標
    const cp = Math.cos(view.pitch);
    const sp = Math.sin(view.pitch);
    const cy = Math.cos(view.yaw);
    const sy = Math.sin(view.yaw);

    const x = view.target.x + view.dist * cp * cy;
    const y = view.target.y + view.dist * sp;
    const z = view.target.z + view.dist * cp * sy;

    camera.position.set(x,y,z);
    camera.lookAt(view.target);
    camera.updateProjectionMatrix();
  }

  function resetViewToFit(R,H){
    const bound = Math.sqrt(R*R + (H*0.5)*(H*0.5));
    view.dist = Math.max(3, bound * 3.0);
    view.target.set(0,0,0);
    view.yaw = 0.9;
    view.pitch = 0.55;
    updateCamera();
  }

  // ピクセル→パンのスケール（距離に応じて自然に）
  function panScale(){
    return view.dist * 0.0012;
  }

  let dragging = false;
  let dragButton = 0; // 0:left, 2:right
  let lastX = 0, lastY = 0;

  cv.addEventListener("pointerdown", (e)=>{
    dragging = true;
    dragButton = e.button;
    lastX = e.clientX;
    lastY = e.clientY;
    cv.classList.add("dragging");
    cv.setPointerCapture(e.pointerId);
  });

  cv.addEventListener("pointerup", (e)=>{
    dragging = false;
    cv.classList.remove("dragging");
    try{ cv.releasePointerCapture(e.pointerId); }catch(_){}
  });

  cv.addEventListener("pointermove", (e)=>{
    if (!dragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;

    if (dragButton === 2) {
      // 右ドラッグ：パン（画面の右＝ワールドの右、画面の上＝ワールドの上）
      // カメラの右・上ベクトルを使って target を動かす
      const s = panScale();
      const forward = new THREE.Vector3().subVectors(view.target, camera.position).normalize();
      const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
      const up = new THREE.Vector3().crossVectors(right, forward).normalize();

      view.target.addScaledVector(right, -dx * s);
      view.target.addScaledVector(up,   dy * s);
      updateCamera();
    } else {
      // 左ドラッグ：回転
      view.yaw   -= dx * 0.006;
      view.pitch -= dy * 0.006;
      view.pitch = Math.max(view.minPitch, Math.min(view.maxPitch, view.pitch));
      updateCamera();
    }
  });

  // ホイールズーム（passive:false）
  cv.addEventListener("wheel", (e)=>{
    e.preventDefault();
    const delta = e.deltaY;
    const factor = Math.exp(delta * 0.0012); // deltaY>0で縮む
    view.dist *= factor;
    view.dist = Math.max(view.minDist, Math.min(view.maxDist, view.dist));
    updateCamera();
  }, { passive:false });

  // -----------------------------
  // Build helpers
  // -----------------------------
  function disposeObject(obj){
    obj.traverse((x)=>{
      if (x.geometry) x.geometry.dispose();
      if (x.material){
        if (Array.isArray(x.material)) x.material.forEach(m=>m.dispose());
        else x.material.dispose();
      }
    });
  }

  function clearRoot(){
    while (root.children.length){
      const obj = root.children.pop();
      disposeObject(obj);
    }
  }

  // 円柱本体は描かず、上面/底面の“円ガイド”だけ
  function buildGuideRings(R, H){
    const ringMatTop = new THREE.LineBasicMaterial({ color: 0xffffff, transparent:true, opacity: 0.20 });
    const ringMatBot = new THREE.LineBasicMaterial({ color: 0xffffff, transparent:true, opacity: 0.14 });

    const seg = 180;

    function ring(z, mat){
      const pts = [];
      for (let k=0;k<=seg;k++){
        const a = TAU * (k/seg);
        pts.push(R*Math.cos(a), R*Math.sin(a), z);
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.Float32BufferAttribute(pts, 3));
      return new THREE.Line(geo, mat);
    }

    root.add(ring(+H/2, ringMatTop));
    root.add(ring(-H/2, ringMatBot));
  }

  function buildPins(N, R, z, colorHex, pred){
    const allowed = [];
    for (let i=0;i<N;i++) if (pred(i)) allowed.push(i);

    const g = new THREE.SphereGeometry(Math.max(0.03, R*0.02), 16, 16);
    const m = new THREE.MeshStandardMaterial({
      color: new THREE.Color(colorHex),
      roughness: 0.25,
      metalness: 0.05
    });

    const group = new THREE.Group();
    for (let i=0;i<N;i++){
      if (!pred(i)) continue;
      const ang = TAU * (i / N) - Math.PI/2;
      const x = R * Math.cos(ang);
      const y = R * Math.sin(ang);
      const s = new THREE.Mesh(g, m);
      s.position.set(x, y, z);
      group.add(s);
    }
    root.add(group);
    return { allowed };
  }

  let lines = null;
  let totalSegments = 0;

  function buildLines(N, M, R, H, topAllowed, bottomAllowed, lineColor){
    const step = mod(M, N);
    const bottomSet = new Set(bottomAllowed);

    const zTop = +H/2;
    const zBot = -H/2;

    const positions = [];
    let count = 0;

    for (let i=0;i<N;i++){
      if (!topAllowed.includes(i)) continue;

      const j0 = mod(i + step, N);
      const j = bottomSet.has(j0) ? j0 : snapToAllowed(N, j0, bottomAllowed);
      if (j == null) continue;

      const a = TAU * (i / N) - Math.PI/2;
      const b = TAU * (j / N) - Math.PI/2;

      const ax = R*Math.cos(a), ay = R*Math.sin(a);
      const bx = R*Math.cos(b), by = R*Math.sin(b);

      positions.push(ax, ay, zTop, bx, by, zBot);
      count++;
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
    geo.setDrawRange(0, 0);

    const mat = new THREE.LineBasicMaterial({
      color: new THREE.Color(lineColor),
      transparent: true,
      opacity: 0.95,
    });

    const obj = new THREE.LineSegments(geo, mat);
    root.add(obj);

    lines = obj;
    totalSegments = count;
  }

  function setLineProgress(p){
    if (!lines) return;
    const geo = lines.geometry;
    const segToShow = Math.floor(Math.max(0, Math.min(1, p)) * totalSegments);
    geo.setDrawRange(0, segToShow * 2);
  }

  // -----------------------------
  // App / UI
  // -----------------------------
  let isPlaying = false;
  let startTime = 0;
  let animDuration = 7.0;

  function updateMetaUI({N,M,step,d,L,topCount,botCount,segCount}){
    metaEl.innerHTML = `
      <div><b>N</b>=${N}, <b>M</b>=${M}, <b>step</b>=${step}</div>
      <div><b>gcd(N,step)</b>=${d} / <b>L</b>=${L}</div>
      <div>上面許可: <b>${topCount}</b> / 底面許可: <b>${botCount}</b></div>
      <div>糸（線分）: <b>${segCount}</b></div>
      <div style="margin-top:6px; opacity:.85;">THREE: ${threeUrl} / 操作: manual</div>
    `;
  }

  function rebuild({ doFit = true } = {}){
    const N = clampInt(inN.value, 3, 2000);
    const M = clampInt(inM.value, 0, 2000000);
    const R = clampNum(inR.value, 0.1, 50);
    const H = clampNum(inH.value, 0.1, 80);

    const topKind = selTop.value;
    const botKind = selBottom.value;

    const topK = clampInt(inTopK.value, 2, 2000);
    const topR = clampInt(inTopR.value, 0, 2000000);
    const botK = clampInt(inBotK.value, 2, 2000);
    const botR = clampInt(inBotR.value, 0, 2000000);

    const lineColor = colLine.value;
    const pinColor  = colPin.value;

    animDuration = clampNum(inAnimT.value, 0.2, 120);

    applyTheme(selTheme.value);

    clearRoot();
    buildGuideRings(R, H);

    const topPred = makeFilter(topKind, topK, topR);
    const botPred = makeFilter(botKind, botK, botR);

    const topPins = buildPins(N, R, +H/2, pinColor, topPred);
    const botPins = buildPins(N, R, -H/2, pinColor, botPred);

    buildLines(N, M, R, H, topPins.allowed, botPins.allowed, lineColor);

    const step = mod(M, N);
    const d = gcd(N, step);
    const L = (step===0) ? 0 : (N/d);

    hud.textContent = `N=${N}, M=${M}（step=${step}） / 上:${topKind} 下:${botKind}`;
    updateMetaUI({
      N,M,step,d,L,
      topCount: topPins.allowed.length,
      botCount: botPins.allowed.length,
      segCount: totalSegments
    });

    isPlaying = false;
    btnAnim.textContent = "▶ アニメ再生";
    setLineProgress(1.0);

    if (doFit) resetViewToFit(R, H);
  }

  // -----------------------------
  // Resize & loop
  // -----------------------------
  function resize(){
    const w = cv.clientWidth;
    const h = cv.clientHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    updateCamera();
  }

  function loop(t){
    requestAnimationFrame(loop);

    if (isPlaying && lines){
      const elapsed = (t - startTime) / 1000;
      const p = Math.min(1, elapsed / animDuration);
      setLineProgress(p);
      if (p >= 1){
        isPlaying = false;
        btnAnim.textContent = "▶ アニメ再生";
      }
    }
    renderer.render(scene, camera);
  }

  function savePNG(){
    setLineProgress(1.0);
    renderer.render(scene, camera);
    const url = renderer.domElement.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = url;
    a.download = "3d-string-art.png";
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  // -----------------------------
  // Events
  // -----------------------------
  btnApply.addEventListener("click", () => rebuild({ doFit:true }));

  btnAnim.addEventListener("click", ()=>{
    if (!lines) return;
    isPlaying = !isPlaying;
    if (isPlaying){
      startTime = performance.now();
      setLineProgress(0.0);
      btnAnim.textContent = "⏸ アニメ停止";
    } else {
      btnAnim.textContent = "▶ アニメ再生";
    }
  });

  btnReset.addEventListener("click", ()=>{
    inN.value="30"; inM.value="3";
    inR.value="3.0"; inH.value="4.0";
    selTop.value="even"; selBottom.value="odd";
    inTopK.value="2"; inTopR.value="0";
    inBotK.value="2"; inBotR.value="1";
    colLine.value="#60a5fa";
    colPin.value="#e5e7eb";
    inAnimT.value="7.0";
    selTheme.value="dark";
    rebuild({ doFit:true });
  });

  btnShot.addEventListener("click", savePNG);

  selTheme.addEventListener("change", ()=> rebuild({ doFit:false }));

  window.addEventListener("resize", resize);

  // -----------------------------
  // Boot
  // -----------------------------
  applyTheme(selTheme.value);
  resize();
  rebuild({ doFit:true });
  requestAnimationFrame(loop);
}
</script>
</body>
</html>
