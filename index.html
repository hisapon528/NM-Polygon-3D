<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D ã‚¹ãƒˆãƒªãƒ³ã‚°ã‚¢ãƒ¼ãƒˆï¼ˆæ­£ N/Mï¼‰</title>

  <style>
    :root{
      /* Theme vars (default: dark) */
      --bg:#0b0f17;
      --bgImg: radial-gradient(1200px 700px at 30% 20%, rgba(17,24,39,1), rgba(5,7,11,1));
      --fg:#e5e7eb;
      --muted:#9ca3af;

      --panel: rgba(17,24,39,.86);
      --panelSolid:#111827;

      --border: rgba(255,255,255,.10);
      --border2: rgba(255,255,255,.14);

      --btnBg: rgba(255,255,255,.06);
      --btnBgHover: rgba(255,255,255,.10);
      --btnBorder: rgba(255,255,255,.14);

      --controlsBg: linear-gradient(to bottom, var(--panelSolid), rgba(17,24,39,.60));
      --boxBg: rgba(0,0,0,.18);
      --cardBg: rgba(255,255,255,.04);

      --inputBg: rgba(0,0,0,.25);

      --overlayBg: rgba(0,0,0,.55);
      --modalBg: rgba(17,24,39,.96);
      --modalBorder: rgba(255,255,255,.10);
      --modalBodyBg: rgba(0,0,0,.18);
      --modalRowBg: rgba(255,255,255,.03);
      --modalRowBorder: rgba(255,255,255,.08);
      --shadow: 0 20px 60px rgba(0,0,0,.45);

      --hudBg: rgba(0,0,0,.55);
      --hudFg: rgba(255,255,255,.92);
      --hudBorder: rgba(255,255,255,.18);
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic",sans-serif;
      background-color: var(--bg);
      background-image: var(--bgImg);
      color:var(--fg);
      overflow:hidden;
    }

    .wrap{
      display:grid;
      grid-template-columns: 440px 1fr;
      height:100vh;
      width:100vw;
    }

    .panel{
      height:100vh;
      overflow-y:auto;
      padding:16px;
      background: var(--panel);
      border-right: 1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(8px);
    }

    h1{ font-size:18px; margin:0 0 10px; }
    .desc{
      font-size:12px; color:var(--muted); line-height:1.55; margin-bottom:12px;
    }

    .controlsTop{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:center;
      position: sticky; top: 0; z-index: 5;
      padding: 10px 0;
      background: var(--controlsBg);
      border-bottom: 1px solid rgba(255,255,255,.06);
    }

    button{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--btnBorder);
      background: var(--btnBg);
      color:var(--fg);
      cursor:pointer;
      user-select:none;
    }
    button:hover{ background: var(--btnBgHover); }

    .btnPrimary{ border-color: rgba(96,165,250,.55); }
    .btnToggle { border-color: rgba(52,211,153,.45); }
    .btnWarn   { border-color: rgba(251,191,36,.55); }

    .rows{
      display:flex; flex-direction:column; gap:10px;
      padding:10px;
      border:1px solid var(--border);
      border-radius:14px;
      background: var(--boxBg);
      margin-bottom: 12px;
    }

    .rowCard{
      display:grid;
      grid-template-columns: 1fr 1fr auto auto auto;
      gap:8px;
      align-items:center;
      padding:10px;
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      background: var(--cardBg);
      box-shadow:none;
    }
    .rowCard .label{
      font-size:11px; color:var(--muted); margin-bottom:4px;
    }
    .rowCard .field{ display:flex; flex-direction:column; }

    input[type="number"]{
      width:100%;
      padding:10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background: var(--inputBg);
      color:var(--fg);
      outline:none;
    }

    .iconBtn{
      width:40px; height:40px;
      display:inline-flex; align-items:center; justify-content:center;
      border-radius:12px;
      border:1px solid var(--border2);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      font-size:16px;
      color: var(--fg);
    }
    .iconBtn:hover{ background: rgba(255,255,255,.10); }

    .swatch{
      width:14px; height:14px; border-radius:6px;
      border:1px solid rgba(255,255,255,.25);
      display:inline-block;
      vertical-align:middle;
      margin-left:6px;
    }
    .rowMeta{
      grid-column: 1 / -1;
      font-size:11px;
      color: var(--muted);
      margin-top:4px;
      line-height:1.55;
    }

    .globalBox{
      margin-top:12px;
      padding:12px;
      border:1px solid var(--border);
      border-radius:14px;
      background: var(--boxBg);
      font-size:12px;
      line-height:1.65;
      color: var(--muted);
    }
    .globalBox b{ color:var(--fg); }

    .viewer{
      position:relative;
      height:100vh;
      width:100%;
    }
    canvas#stage{
      width:100%;
      height:100%;
      display:block;
      cursor: grab;
      touch-action:none;
    }
    canvas#stage.dragging{ cursor: grabbing; }

    .hud{
      position:absolute;
      left:12px; top:12px;
      background: var(--hudBg);
      border:1px solid var(--hudBorder);
      color: var(--hudFg);
      padding:10px 12px;
      border-radius:12px;
      font-size:12px;
      line-height:1.55;
      pointer-events:none;
      white-space:nowrap;
      max-width: 70vw;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    /* Modal */
    .modalOverlay{
      position:fixed; inset:0;
      background: var(--overlayBg);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index: 1000;
    }
    .modal{
      width:min(580px, 96vw);
      background: var(--modalBg);
      border:1px solid var(--modalBorder);
      border-radius:18px;
      padding:14px;
      box-shadow: var(--shadow);
    }
    .modalHeader{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; margin-bottom:10px;
    }
    .modalTitle{ font-size:14px; font-weight:700; }
    .closeBtn{
      width:38px; height:38px; border-radius:12px;
      border:1px solid var(--border2);
      background: rgba(255,255,255,.06);
      color:var(--fg); cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      font-size:16px;
    }
    .closeBtn:hover{ background: rgba(255,255,255,.10); }

    .modalBody{
      display:flex; flex-direction:column; gap:10px;
      padding:10px;
      border:1px solid var(--modalRowBorder);
      border-radius:14px;
      background: var(--modalBodyBg);
      font-size:12px;
    }
    .modalRow{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:8px 8px;
      border-radius:12px;
      border:1px solid var(--modalRowBorder);
      background: var(--modalRowBg);
    }
    .modalRow .left{ color: var(--fg); }
    .modalRow .right{ display:flex; gap:8px; align-items:center; }

    input[type="color"]{
      width:44px; height:32px;
      border:none; background: transparent; padding:0;
      cursor:pointer;
    }
    .miniInput{
      width: 170px;
      padding:8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background: var(--inputBg);
      color: var(--fg);
      outline:none;
      font-size: 12px;
    }
    select.miniInput{ width: 190px; }

    .tiny{
      font-size:11px;
      color: var(--muted);
      line-height: 1.5;
      margin-top: 8px;
    }
    .footerNote{
      margin-top:10px;
      font-size:11px;
      color:var(--muted);
      line-height:1.55;
      padding-bottom: 16px;
    }
  </style>
</head>

<body>
<div class="wrap">
  <div class="panel">
    <h1>3D ã‚¹ãƒˆãƒªãƒ³ã‚°ã‚¢ãƒ¼ãƒˆï¼ˆæ­£ N/Mï¼‰</h1>
    <div class="desc">
      2Dç‰ˆã¨åŒæ§˜ã« <b>start</b> ã‹ã‚‰ <b>+M (mod N)</b> ã§ç‚¹ã‚’è¾¿ã‚Šï¼Œ<b>start ã«æˆ»ã‚‹ã¾ã§</b> 1æœ¬ã®æŠ˜ã‚Œç·šã¨ã—ã¦çµã³ã¾ã™ã€‚<br/>
      å„è¡Œï¼ˆå›³å½¢ï¼‰ã”ã¨ã« <b>N/M</b> ã‚’è¨­å®šã—ï¼Œ<b>â–¶/âš™/å‰Šé™¤</b> ãŒä½¿ãˆã¾ã™ã€‚<br/>
      æ“ä½œï¼šå·¦ãƒ‰ãƒ©ãƒƒã‚°=å›è»¢ / å³ãƒ‰ãƒ©ãƒƒã‚°=ãƒ‘ãƒ³ / ãƒ›ã‚¤ãƒ¼ãƒ«=ã‚ºãƒ¼ãƒ 
    </div>

    <div class="controlsTop">
      <button id="addRow" class="btnPrimary">ï¼‹ è¿½åŠ </button>
      <button id="resetAll" class="btnWarn">ãƒªã‚»ãƒƒãƒˆ</button>
      <button id="openGlobal" class="btnWarn">è¨­å®š</button>
      <button id="saveAll">ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¿å­˜ï¼ˆPNGï¼‰</button>
    </div>

    <div class="rows" id="rows"></div>
    <div class="globalBox" id="globalInfo"></div>

    <div class="footerNote">
      â€» M ã¯å†…éƒ¨ã§ <b>M (mod N)</b>ï¼Œå§‹ç‚¹ã¯ <b>start (mod N)</b> ã«æ­£è¦åŒ–ã—ã¾ã™ã€‚<br/>
      â€» ç¾æ®µéšã§ã¯ã€Œä¸Šé¢/åº•é¢ã®ç‚¹ã®åˆ¶é™ã€ã¯å»ƒæ­¢ã—ï¼Œå¸¸ã«å…¨ç‚¹ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚<br/>
    </div>
  </div>

  <div class="viewer">
    <canvas id="stage"></canvas>
    <div class="hud" id="hud">èµ·å‹•ä¸­â€¦</div>
  </div>
</div>

<!-- è¡Œè¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆ2Dç‰ˆã¨åŒç­‰ï¼‰ -->
<div class="modalOverlay" id="rowModalOverlay">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="modalHeader">
      <div class="modalTitle" id="rowModalTitle">è¨­å®š</div>
      <button class="closeBtn" id="rowModalClose" title="é–‰ã˜ã‚‹">âœ•</button>
    </div>

    <div class="modalBody">
      <div class="modalRow">
        <div class="left">ã“ã®å›³å½¢ã‚’è¡¨ç¤º</div>
        <div class="right"><input type="checkbox" id="optVisible"></div>
      </div>

      <div class="modalRow">
        <div class="left">é ‚ç‚¹ã‚’è¡¨ç¤º</div>
        <div class="right"><input type="checkbox" id="optShowPoints"></div>
      </div>

      <div class="modalRow">
        <div class="left">é ‚ç‚¹ç•ªå·ã‚’è¡¨ç¤º</div>
        <div class="right"><input type="checkbox" id="optShowLabels"></div>
      </div>

      <div class="modalRow">
        <div class="left">é ‚ç‚¹ç•ªå·ã‚µã‚¤ã‚ºï¼ˆpxï¼‰</div>
        <div class="right">
          <input class="miniInput" type="number" id="optLabelSize" min="8" step="1" />
        </div>
      </div>

      <div class="modalRow">
        <div class="left">ç·šã®è‰²</div>
        <div class="right"><input type="color" id="optLineColor"></div>
      </div>

      <div class="modalRow">
        <div class="left">é ‚ç‚¹ã®è‰²</div>
        <div class="right"><input type="color" id="optPointColor"></div>
      </div>

      <div class="modalRow">
        <div class="left">ã‚¢ãƒ‹ãƒ¡æ™‚é–“ï¼ˆç§’ï¼‰</div>
        <div class="right">
          <input class="miniInput" type="number" id="optAnimTime" min="0.2" step="0.1" />
        </div>
      </div>

      <div class="modalRow">
        <div class="left">å§‹ç‚¹ï¼ˆstartï¼‰</div>
        <div class="right">
          <input class="miniInput" type="number" id="optStart" step="1" />
        </div>
      </div>

      <div class="tiny">
        â€»å§‹ç‚¹ã¯å†…éƒ¨ã§ <b>start mod N</b> ã«æ­£è¦åŒ–ã—ã¾ã™ã€‚<br/>
        â€»ç‚¹ç•ªå·ã‚µã‚¤ã‚ºã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ <b>250</b> ã§ã™ã€‚<br/>
      </div>
    </div>
  </div>
</div>

<!-- å…¨ä½“è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="modalOverlay" id="globalModalOverlay">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="modalHeader">
      <div class="modalTitle">å…¨ä½“è¨­å®š</div>
      <button class="closeBtn" id="globalModalClose" title="é–‰ã˜ã‚‹">âœ•</button>
    </div>

    <div class="modalBody">
      <div class="modalRow">
        <div class="left">èƒŒæ™¯</div>
        <div class="right">
          <select id="optTheme" class="miniInput">
            <option value="dark">ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰</option>
            <option value="light">ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰</option>
          </select>
        </div>
      </div>

      <div class="modalRow">
        <div class="left">å††ã®å¤–æ ã®è‰²</div>
        <div class="right">
          <input type="color" id="optCircleColor">
        </div>
      </div>

      <div class="modalRow">
        <div class="left">å††æŸ± åŠå¾„ R</div>
        <div class="right">
          <input class="miniInput" type="number" id="optRadius" min="0.1" step="0.1">
        </div>
      </div>

      <div class="modalRow">
        <div class="left">å††æŸ± é«˜ã• H</div>
        <div class="right">
          <input class="miniInput" type="number" id="optHeight" min="0.1" step="0.1">
        </div>
      </div>

      <div class="tiny">
        â€»å††æŸ±æœ¬ä½“ï¼ˆå´é¢ï¼‰ã¯æã‹ãšï¼Œä¸Šé¢/åº•é¢ã®å††ã‚¬ã‚¤ãƒ‰ã®ã¿æç”»ã—ã¾ã™ã€‚<br/>
      </div>
    </div>
  </div>
</div>

<script>
function loadScriptWithFallback(urls){
  return new Promise((resolve, reject) => {
    let i = 0;
    const tryNext = () => {
      if (i >= urls.length) { reject(new Error("All CDN failed: " + urls.join(" | "))); return; }
      const url = urls[i++];
      const s = document.createElement("script");
      s.src = url;
      s.async = true;
      s.onload = () => resolve(url);
      s.onerror = () => { s.remove(); tryNext(); };
      document.head.appendChild(s);
    };
    tryNext();
  });
}

window.addEventListener("load", async () => {
  const hud = document.getElementById("hud");
  try{
    hud.textContent = "Three.js ã‚’èª­ã¿è¾¼ã¿ä¸­â€¦";
    const threeUrl = await loadScriptWithFallback([
      "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js",
      "https://unpkg.com/three@0.160.0/build/three.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"
    ]);
    startApp({ threeUrl });
  }catch(e){
    hud.textContent = "èµ·å‹•å¤±æ•—: CDNãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚";
    console.error(e);
  }
});

function startApp({ threeUrl }){
  // =========================================================
  // DOM
  // =========================================================
  const stage = document.getElementById("stage");
  const hud = document.getElementById("hud");
  const rowsEl = document.getElementById("rows");
  const globalInfoEl = document.getElementById("globalInfo");

  const btnAdd = document.getElementById("addRow");
  const btnReset = document.getElementById("resetAll");
  const btnSave = document.getElementById("saveAll");
  const btnOpenGlobal = document.getElementById("openGlobal");

  // Row modal
  const rowModalOverlay = document.getElementById('rowModalOverlay');
  const rowModalTitle = document.getElementById('rowModalTitle');
  const rowModalClose = document.getElementById('rowModalClose');
  const optVisible = document.getElementById('optVisible');
  const optShowPoints = document.getElementById('optShowPoints');
  const optShowLabels = document.getElementById('optShowLabels');
  const optLabelSize = document.getElementById('optLabelSize');
  const optLineColor = document.getElementById('optLineColor');
  const optPointColor = document.getElementById('optPointColor');
  const optAnimTime = document.getElementById('optAnimTime');
  const optStart = document.getElementById('optStart');

  // Global modal
  const globalModalOverlay = document.getElementById('globalModalOverlay');
  const globalModalClose = document.getElementById('globalModalClose');
  const optTheme = document.getElementById('optTheme');
  const optCircleColor = document.getElementById('optCircleColor');
  const optRadius = document.getElementById('optRadius');
  const optHeight = document.getElementById('optHeight');

  // =========================================================
  // Math utils
  // =========================================================
  const TAU = Math.PI * 2;
  const mod = (n, m) => ((n % m) + m) % m;

  function gcd(a,b){
    a = Math.abs(a); b = Math.abs(b);
    while(b!==0){ const t=a%b; a=b; b=t; }
    return a;
  }

  // 2Dã¨åŒæ§˜ã®ã€Œå·¡å›ã€ã‚’3Dãƒãƒ¼ãƒ‰åˆ—ã¸
  // nodes: [{side:"T"|"B", idx:int}, ...] æœ«å°¾ã¯ start(T) ã«æˆ»ã£ãŸç‚¹
  function buildCycle3D(N, M, start){
    const step = mod(M, N);
    const s = mod(start, N);

    const nodes = [{ side:"T", idx:s }];

    if (N <= 0 || step === 0){
      nodes.push({ side:"T", idx:s });
      return { valid:true, nodes, step, edges: Math.max(0, nodes.length-1) };
    }

    let curSide = "T";
    let curIdx = s;

    const seen = new Set([`T:${s}`]);
    const maxSteps = 2*N + 10;

    for (let t=0; t<maxSteps; t++){
      const nextSide = (curSide === "T") ? "B" : "T";
      const nextIdx = mod(curIdx + step, N);

      nodes.push({ side: nextSide, idx: nextIdx });

      if (nextSide === "T" && nextIdx === s){
        return { valid:true, nodes, step, edges: Math.max(0, nodes.length-1) };
      }

      const key = `${nextSide}:${nextIdx}`;
      if (seen.has(key)) break;
      seen.add(key);

      curSide = nextSide;
      curIdx = nextIdx;
    }

    return { valid:false, nodes, step, edges: Math.max(0, nodes.length-1) };
  }

  // =========================================================
  // Theme manager (CSS vars + scene background)
  // =========================================================
  class ThemeManager{
    constructor(){
      this.state = {
        theme: 'dark',
        circleHex: '#b0b0b0',
      };
    }
    hexToRgba(hex, a){
      const h = hex.replace('#','').trim();
      const v = h.length===3 ? h.split('').map(ch=>ch+ch).join('') : h.padStart(6,'0').slice(0,6);
      const r = parseInt(v.slice(0,2),16);
      const g = parseInt(v.slice(2,4),16);
      const b = parseInt(v.slice(4,6),16);
      return `rgba(${r},${g},${b},${a})`;
    }
    applyTheme(scheduleDrawFn){
      const root = document.documentElement.style;
      if (this.state.theme === 'light'){
        root.setProperty('--bg', '#ffffff');
        root.setProperty('--bgImg', 'none');
        root.setProperty('--fg', '#111827');
        root.setProperty('--muted', '#374151');

        root.setProperty('--panel', '#ffffff');
        root.setProperty('--panelSolid', '#ffffff');

        root.setProperty('--border', 'rgba(0,0,0,.12)');
        root.setProperty('--border2', 'rgba(0,0,0,.16)');

        root.setProperty('--btnBg', '#ffffff');
        root.setProperty('--btnBgHover', 'rgba(0,0,0,.06)');
        root.setProperty('--btnBorder', 'rgba(0,0,0,.30)');

        root.setProperty('--controlsBg', 'linear-gradient(to bottom, rgba(255,255,255,1), rgba(255,255,255,.65))');
        root.setProperty('--boxBg', 'rgba(0,0,0,.03)');
        root.setProperty('--cardBg', 'rgba(0,0,0,.02)');

        root.setProperty('--overlayBg', 'rgba(0,0,0,.25)');
        root.setProperty('--modalBg', '#ffffff');
        root.setProperty('--modalBorder', 'rgba(0,0,0,.18)');
        root.setProperty('--modalBodyBg', '#ffffff');
        root.setProperty('--modalRowBg', '#ffffff');
        root.setProperty('--modalRowBorder', 'rgba(0,0,0,.12)');
        root.setProperty('--inputBg', '#ffffff');
        root.setProperty('--shadow', '0 20px 60px rgba(0,0,0,.18)');

        root.setProperty('--hudBg', 'rgba(255,255,255,.92)');
        root.setProperty('--hudFg', 'rgba(17,24,39,.98)');
        root.setProperty('--hudBorder', 'rgba(0,0,0,.20)');

      } else {
        root.setProperty('--bg', '#0b0f17');
        root.setProperty('--bgImg', 'radial-gradient(1200px 700px at 30% 20%, rgba(17,24,39,1), rgba(5,7,11,1))');
        root.setProperty('--fg', '#e5e7eb');
        root.setProperty('--muted', '#9ca3af');

        root.setProperty('--panel', 'rgba(17,24,39,.86)');
        root.setProperty('--panelSolid', '#111827');

        root.setProperty('--border', 'rgba(255,255,255,.10)');
        root.setProperty('--border2', 'rgba(255,255,255,.14)');

        root.setProperty('--btnBg', 'rgba(255,255,255,.06)');
        root.setProperty('--btnBgHover', 'rgba(255,255,255,.10)');
        root.setProperty('--btnBorder', 'rgba(255,255,255,.14)');

        root.setProperty('--controlsBg', 'linear-gradient(to bottom, var(--panelSolid), rgba(17,24,39,.60))');
        root.setProperty('--boxBg', 'rgba(0,0,0,.18)');
        root.setProperty('--cardBg', 'rgba(255,255,255,.04)');

        root.setProperty('--overlayBg', 'rgba(0,0,0,.55)');
        root.setProperty('--modalBg', 'rgba(17,24,39,.96)');
        root.setProperty('--modalBorder', 'rgba(255,255,255,.10)');
        root.setProperty('--modalBodyBg', 'rgba(0,0,0,.18)');
        root.setProperty('--modalRowBg', 'rgba(255,255,255,.03)');
        root.setProperty('--modalRowBorder', 'rgba(255,255,255,.08)');
        root.setProperty('--inputBg', 'rgba(0,0,0,.25)');
        root.setProperty('--shadow', '0 20px 60px rgba(0,0,0,.45)');

        root.setProperty('--hudBg', 'rgba(0,0,0,.55)');
        root.setProperty('--hudFg', 'rgba(255,255,255,.92)');
        root.setProperty('--hudBorder', 'rgba(255,255,255,.18)');
      }
      scheduleDrawFn();
    }
  }
  const themeManager = new ThemeManager();

  // =========================================================
  // Three.js scene
  // =========================================================
  const renderer = new THREE.WebGLRenderer({
    canvas: stage,
    antialias: true,
    alpha: false,
    preserveDrawingBuffer: true,
  });
  renderer.setPixelRatio(Math.min(2.5, window.devicePixelRatio || 1));

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(55, 1, 0.01, 500);

  scene.add(new THREE.AmbientLight(0xffffff, 0.60));
  const dir = new THREE.DirectionalLight(0xffffff, 0.90);
  dir.position.set(6, 10, 8);
  scene.add(dir);

  const root3D = new THREE.Group();
  scene.add(root3D);

  const guideGroup = new THREE.Group(); // å††ã‚¬ã‚¤ãƒ‰ï¼ˆå…¨ä½“è¨­å®šï¼‰
  root3D.add(guideGroup);

  // =========================================================
  // Manual camera control (left rotate / right pan / wheel zoom)
  // =========================================================
  stage.addEventListener("contextmenu", (e)=>e.preventDefault());

  const view = {
    target: new THREE.Vector3(0,0,0),
    dist: 12,
    yaw: 0.9,
    pitch: 0.55,
    minDist: 2.0,
    maxDist: 120.0,
    minPitch: -1.45,
    maxPitch:  1.45
  };

  function updateCamera(){
    const cp = Math.cos(view.pitch);
    const sp = Math.sin(view.pitch);
    const cy = Math.cos(view.yaw);
    const sy = Math.sin(view.yaw);

    const x = view.target.x + view.dist * cp * cy;
    const y = view.target.y + view.dist * sp;
    const z = view.target.z + view.dist * cp * sy;

    camera.position.set(x,y,z);
    camera.lookAt(view.target);
    camera.updateProjectionMatrix();
  }

  function resetViewToFit(R,H){
    const bound = Math.sqrt(R*R + (H*0.5)*(H*0.5));
    view.dist = Math.max(3, bound * 3.0);
    view.target.set(0,0,0);
    view.yaw = 0.9;
    view.pitch = 0.55;
    updateCamera();
  }

  function panScale(){
    return view.dist * 0.0012;
  }

  let dragging = false;
  let dragButton = 0;
  let lastX = 0, lastY = 0;

  stage.addEventListener("pointerdown", (e)=>{
    dragging = true;
    dragButton = e.button;
    lastX = e.clientX;
    lastY = e.clientY;
    stage.classList.add("dragging");
    stage.setPointerCapture(e.pointerId);
  });

  stage.addEventListener("pointerup", (e)=>{
    dragging = false;
    stage.classList.remove("dragging");
    try{ stage.releasePointerCapture(e.pointerId); }catch(_){}
  });

  stage.addEventListener("pointermove", (e)=>{
    if (!dragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;

    if (dragButton === 2) {
      const s = panScale();
      const forward = new THREE.Vector3().subVectors(view.target, camera.position).normalize();
      const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
      const up = new THREE.Vector3().crossVectors(right, forward).normalize();

      view.target.addScaledVector(right, -dx * s);
      view.target.addScaledVector(up,   dy * s);
      updateCamera();
    } else {
      view.yaw   -= dx * 0.006;
      view.pitch -= dy * 0.006;
      view.pitch = Math.max(view.minPitch, Math.min(view.maxPitch, view.pitch));
      updateCamera();
    }
  });

  stage.addEventListener("wheel", (e)=>{
    e.preventDefault();
    const factor = Math.exp(e.deltaY * 0.0012);
    view.dist *= factor;
    view.dist = Math.max(view.minDist, Math.min(view.maxDist, view.dist));
    updateCamera();
  }, { passive:false });

  // =========================================================
  // Global settings (radius/height/theme/circleColor)
  // =========================================================
  const globalState = {
    radius: 3.0,
    height: 4.0,
  };

  function hexToThreeColor(hex){
    try{ return new THREE.Color(hex); }catch(_){ return new THREE.Color(0xffffff); }
  }

  function rebuildGuides(){
    // clear
    while (guideGroup.children.length){
      const obj = guideGroup.children.pop();
      obj.geometry?.dispose?.();
      obj.material?.dispose?.();
    }

    const R = globalState.radius;
    const H = globalState.height;

    const seg = 180;

    const circleColor = hexToThreeColor(themeManager.state.circleHex);
    const isLight = (themeManager.state.theme === 'light');
    const opacity = isLight ? 0.55 : 0.55;

    const mat = new THREE.LineBasicMaterial({
      color: circleColor,
      transparent: true,
      opacity
    });

    function ring(z){
      const pts = [];
      for (let k=0;k<=seg;k++){
        const a = TAU * (k/seg);
        pts.push(R*Math.cos(a), R*Math.sin(a), z);
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.Float32BufferAttribute(pts, 3));
      return new THREE.Line(geo, mat.clone());
    }

    guideGroup.add(ring(+H/2));
    guideGroup.add(ring(-H/2));

    // scene background
    scene.background = new THREE.Color(isLight ? "#ffffff" : "#0b0f17");

    resetViewToFit(R, H);
  }

  // =========================================================
  // Row model
  // =========================================================
  const DEFAULT_ANIM_TIME = 8.0;
  const DEFAULT_START = 0;
  const DEFAULT_LABEL_SIZE = 250; // â˜… requested default

  const palette = [
    "#60a5fa", "#f472b6", "#34d399", "#f59e0b", "#a78bfa",
    "#22d3ee", "#fb7185", "#84cc16", "#e879f9", "#f87171",
  ];

  class RowModel{
    constructor(initial){
      Object.assign(this, initial);
      // runtime handles
      this.group = null;     // THREE.Group for this row
      this.pathLine = null;  // THREE.Line
      this.pathBasePos = null; // Float32Array
      this.pathEdges = 0;

      this.animPlaying = false;
      this.animProgressEdges = 0.0;
      this.animSpeedEdgesPerSec = 0.0;
    }
  }

  // =========================================================
  // Build row objects (pins + labels + path)
  // =========================================================
  function makeLabelSprite(text, fontPx, fill, stroke){
    const size = 256;
    const canvas = document.createElement("canvas");
    canvas.width = size; canvas.height = size;
    const c = canvas.getContext("2d");

    c.clearRect(0,0,size,size);
    c.font = `800 ${fontPx}px system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif`;
    c.textAlign = "center";
    c.textBaseline = "middle";

    c.lineJoin = "round";
    c.lineWidth = Math.max(6, fontPx * 0.28);
    c.strokeStyle = stroke;
    c.strokeText(text, size/2, size/2);

    c.fillStyle = fill;
    c.fillText(text, size/2, size/2);

    const tex = new THREE.CanvasTexture(canvas);
    tex.anisotropy = 4;
    tex.needsUpdate = true;

    const mat = new THREE.SpriteMaterial({
      map: tex,
      transparent: true,
      depthWrite: false,
      depthTest: true
    });

    const spr = new THREE.Sprite(mat);
    spr.userData._labelTexture = tex;
    return spr;
  }

  function getLabelPalette(){
    if (themeManager.state.theme === 'light'){
      return { fill: "rgba(17,24,39,0.96)", stroke: "rgba(255,255,255,0.92)" };
    }
    return { fill: "rgba(255,255,255,0.92)", stroke: "rgba(0,0,0,0.78)" };
  }

  function disposeObject(obj){
    obj.traverse((x)=>{
      if (x.geometry) x.geometry.dispose();
      if (x.material){
        if (Array.isArray(x.material)) x.material.forEach(m=>m.dispose());
        else x.material.dispose();
      }
      if (x.userData?._labelTexture) x.userData._labelTexture.dispose?.();
      if (x.material?.map) x.material.map.dispose?.();
    });
  }

  function clearRow3D(r){
    if (!r.group) return;
    root3D.remove(r.group);
    disposeObject(r.group);
    r.group = null;
    r.pathLine = null;
    r.pathBasePos = null;
    r.pathEdges = 0;
  }

  function setRowLineProgress(r, pEdges){
    if (!r.pathLine || !r.pathBasePos) return;
    const edges = r.pathEdges;
    const geo = r.pathLine.geometry;
    const posAttr = geo.getAttribute("position");
    const pos = posAttr.array;

    const t = Math.max(0, Math.min(edges, pEdges));
    const whole = Math.floor(t);
    const frac = t - whole;

    if (edges <= 0){
      geo.setDrawRange(0, 0);
      return;
    }

    // visible vertices count
    if (whole < edges && frac > 0){
      const visibleVerts = whole + 2;
      geo.setDrawRange(0, visibleVerts);

      const aIdx = whole;
      const bIdx = whole + 1;

      const ax = r.pathBasePos[aIdx*3+0], ay = r.pathBasePos[aIdx*3+1], az = r.pathBasePos[aIdx*3+2];
      const bx = r.pathBasePos[bIdx*3+0], by = r.pathBasePos[bIdx*3+1], bz = r.pathBasePos[bIdx*3+2];

      pos[bIdx*3+0] = ax + (bx-ax)*frac;
      pos[bIdx*3+1] = ay + (by-ay)*frac;
      pos[bIdx*3+2] = az + (bz-az)*frac;

      posAttr.needsUpdate = true;
      return;
    }

    const visibleVerts = whole + 1;
    geo.setDrawRange(0, visibleVerts);

    if (visibleVerts >= 1){
      const last = visibleVerts - 1;
      pos[last*3+0] = r.pathBasePos[last*3+0];
      pos[last*3+1] = r.pathBasePos[last*3+1];
      pos[last*3+2] = r.pathBasePos[last*3+2];
      posAttr.needsUpdate = true;
    }
  }

  function buildRow3D(r){
    clearRow3D(r);

    if (!r.visible) return;

    const N = r.N;
    const M = r.M;

    if (!Number.isInteger(N) || !Number.isInteger(M) || N < 3 || M < 1){
      return;
    }

    const R = globalState.radius;
    const H = globalState.height;

    const info = buildCycle3D(N, M, r.start);

    if (!info.valid || info.edges <= 0){
      return;
    }

    const group = new THREE.Group();
    r.group = group;
    root3D.add(group);

    const zTop = +H/2;
    const zBot = -H/2;

    // Points (pins)
    if (r.showPoints){
      const g = new THREE.SphereGeometry(Math.max(0.03, R*0.02), 16, 16);
      const m = new THREE.MeshStandardMaterial({
        color: new THREE.Color(r.pointColor),
        roughness: 0.25,
        metalness: 0.05
      });

      for (let i=0;i<N;i++){
        const ang = TAU*(i/N) - Math.PI/2;
        const x = R*Math.cos(ang);
        const y = R*Math.sin(ang);

        const sTop = new THREE.Mesh(g, m);
        sTop.position.set(x,y,zTop);
        group.add(sTop);

        const sBot = new THREE.Mesh(g, m);
        sBot.position.set(x,y,zBot);
        group.add(sBot);
      }
    }

    // Labels
    if (r.showLabels){
      const { fill, stroke } = getLabelPalette();
      const fontPx = Math.max(8, Math.floor(Number(r.labelSizePx) || DEFAULT_LABEL_SIZE));
      const worldSize = Math.max(0.16, R * 0.16); // label sprite size in world
      const off = Math.max(0.22, R * 0.12);

      for (let i=0;i<N;i++){
        const ang = TAU*(i/N) - Math.PI/2;
        const x = R*Math.cos(ang);
        const y = R*Math.sin(ang);
        const len = Math.hypot(x,y) || 1;
        const nx = x/len, ny=y/len;

        // top label
        const sprT = makeLabelSprite(String(i), fontPx, fill, stroke);
        sprT.position.set(x + nx*off, y + ny*off, zTop);
        sprT.scale.set(worldSize, worldSize, 1);
        group.add(sprT);

        // bottom label
        const sprB = makeLabelSprite(String(i), fontPx, fill, stroke);
        sprB.position.set(x + nx*off, y + ny*off, zBot);
        sprB.scale.set(worldSize, worldSize, 1);
        group.add(sprB);
      }
    }

    // Path line (single polyline alternating top/bottom)
    const pts = [];
    for (const nd of info.nodes){
      const ang = TAU*(nd.idx/N) - Math.PI/2;
      const x = R*Math.cos(ang);
      const y = R*Math.sin(ang);
      const z = (nd.side === "T") ? zTop : zBot;
      pts.push(x,y,z);
    }

    r.pathEdges = Math.max(0, pts.length/3 - 1);

    const arr = new Float32Array(pts);
    r.pathBasePos = new Float32Array(arr);

    const geo = new THREE.BufferGeometry();
    geo.setAttribute("position", new THREE.Float32BufferAttribute(arr, 3));
    geo.setDrawRange(0, 0);

    const mat = new THREE.LineBasicMaterial({
      color: new THREE.Color(r.lineColor),
      transparent:true,
      opacity:0.95
    });

    const line = new THREE.Line(geo, mat);
    r.pathLine = line;
    group.add(line);

    // initial draw: full if not animPlaying
    if (!r.animPlaying){
      setRowLineProgress(r, r.pathEdges);
    } else {
      setRowLineProgress(r, 0);
    }
  }

  // =========================================================
  // App state (rows + UI)
  // =========================================================
  class App{
    constructor(){
      this.nextId = 1;
      this.rows = [];
      this.rafId = null;
      this.lastT = null;

      // modal state
      this.modalRow = null;
      this.modalRowCard = null;
    }

    newRowDefaults(){
      const idx = this.rows.length;
      const base = palette[idx % palette.length];

      return new RowModel({
        id: this.nextId++,
        N: null,
        M: null,

        start: DEFAULT_START,
        animTimeSec: DEFAULT_ANIM_TIME,

        visible: true,
        showPoints: true,
        showLabels: false,

        labelSizePx: DEFAULT_LABEL_SIZE, // â˜… 250

        lineColor: base,
        pointColor: base,
      });
    }

    rowTitle(r){
      const n = (r.N == null ? "" : r.N);
      const m = (r.M == null ? "" : r.M);
      return `#${r.id}  N=${n}, M=${m}`;
    }

    // row meta info
    getCycleInfo(r){
      const N=r.N, M=r.M;
      if (!Number.isInteger(N) || !Number.isInteger(M) || N<3 || M<1){
        return { valid:false, edges:0, step:0, d:0, L:0, startN:0 };
      }
      const step = mod(M, N);
      const startN = mod(r.start, N);
      const d = gcd(N, step);
      const L = (step===0) ? 0 : (N/d);
      const cyc = buildCycle3D(N, M, r.start);
      return { valid:cyc.valid, edges:cyc.edges, step, d, L, startN };
    }

    anyAnimationPlaying(){
      return this.rows.some(r => r.animPlaying);
    }

    resize(){
      const w = stage.clientWidth;
      const h = stage.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      updateCamera();
    }

    drawAll(){
      this.resize();

      // rebuild guides each time? expensive; only when global changes
      // here: just render
      renderer.render(scene, camera);
    }

    scheduleDraw(){
      // build 3D for all rows (cheap enough for minimal)
      // We rebuild only if needed; for simplicity: rebuild all visible rows
      for (const r of this.rows){
        // if already built, still ok; but if settings changed we rebuild anyway
        buildRow3D(r);
      }

      this.updateGlobalInfo();
      this.drawAll();

      if (this.anyAnimationPlaying() && !this.rafId){
        this.rafId = requestAnimationFrame((t)=>this.tick(t));
      }
      if (!this.anyAnimationPlaying() && this.rafId){
        cancelAnimationFrame(this.rafId);
        this.rafId = null;
        this.lastT = null;
      }
    }

    tick(t){
      if (this.lastT == null) this.lastT = t;
      const dt = (t - this.lastT) / 1000;
      this.lastT = t;

      for (const r of this.rows){
        if (!r.animPlaying) continue;

        const info = this.getCycleInfo(r);
        if (!info.valid || info.edges <= 0){
          r.animPlaying = false;
          continue;
        }

        r.animProgressEdges += r.animSpeedEdgesPerSec * dt;

        if (r.animProgressEdges >= info.edges){
          r.animProgressEdges = info.edges;
          r.animPlaying = false;

          // update icon
          const card = rowsEl.querySelector(`.rowCard[data-row-id="${r.id}"]`);
          if (card && card._setAnimIcon) card._setAnimIcon();
        }

        // apply stroke
        setRowLineProgress(r, r.animProgressEdges);
      }

      this.drawAll();
      this.updateGlobalInfo();

      if (this.anyAnimationPlaying()){
        this.rafId = requestAnimationFrame((tt)=>this.tick(tt));
      } else {
        this.rafId = null;
        this.lastT = null;
      }
    }

    updateGlobalInfo(){
      const total = this.rows.length;
      const playing = this.rows.filter(r => r.animPlaying).length;
      globalInfoEl.innerHTML = `
        <b>è¡¨ç¤ºæ•°</b>: ${total}<br/>
        <b>ã‚¢ãƒ‹ãƒ¡ä¸­</b>: ${playing} / ${total}<br/>
        <b>R</b>: ${globalState.radius.toFixed(1)} , <b>H</b>: ${globalState.height.toFixed(1)}<br/>
        <span style="opacity:.85">THREE: ${threeUrl}</span>
      `;
    }

    createRowUI(r){
      const app = this;

      const card = document.createElement('div');
      card.className = 'rowCard';
      card.dataset.rowId = String(r.id);

      // N input
      const fieldN = document.createElement('div');
      fieldN.className = 'field';
      fieldN.innerHTML = `<div class="label">N</div>`;
      const inN = document.createElement('input');
      inN.type = 'number';
      inN.min = '1';
      inN.step = '1';
      inN.placeholder = 'ï¼ˆæœªå…¥åŠ›ï¼‰';
      inN.value = (r.N == null ? '' : String(r.N));
      fieldN.appendChild(inN);

      // M input
      const fieldM = document.createElement('div');
      fieldM.className = 'field';
      fieldM.innerHTML = `<div class="label">M</div>`;
      const inM = document.createElement('input');
      inM.type = 'number';
      inM.min = '1';
      inM.step = '1';
      inM.placeholder = 'ï¼ˆæœªå…¥åŠ›ï¼‰';
      inM.value = (r.M == null ? '' : String(r.M));
      fieldM.appendChild(inM);

      // Buttons
      const btnAnim = document.createElement('button');
      btnAnim.className = 'iconBtn';
      btnAnim.title = 'ã“ã®è¡Œã®ã‚¢ãƒ‹ãƒ¡ å†ç”Ÿ/åœæ­¢';
      btnAnim.textContent = 'â–¶';

      const btnGear = document.createElement('button');
      btnGear.className = 'iconBtn';
      btnGear.title = 'è¨­å®š';
      btnGear.textContent = 'âš™';

      const btnDel = document.createElement('button');
      btnDel.className = 'iconBtn';
      btnDel.title = 'å‰Šé™¤';
      btnDel.textContent = 'ğŸ—‘';

      // Meta
      const meta = document.createElement('div');
      meta.className = 'rowMeta';

      function updateMeta(){
        const N=r.N, M=r.M;
        if (!Number.isInteger(N) || !Number.isInteger(M)){
          meta.textContent = `æœªå…¥åŠ›ï¼ˆN,Mã‚’å…¥ã‚Œã‚‹ã¨æç”»ã—ã¾ã™ï¼‰`;
          return;
        }
        if (N < 3){
          meta.textContent = `æ³¨æ„: N=${N} ã¯å¤šè§’å½¢ã«ãªã‚Šã¾ã›ã‚“ï¼ˆNâ‰¥3æ¨å¥¨ï¼‰`;
          return;
        }
        if (M < 1){
          meta.textContent = `æ³¨æ„: M ã¯ 1 ä»¥ä¸Š`;
          return;
        }
        const info = app.getCycleInfo(r);
        const sw = `<span class="swatch" style="background:${r.lineColor}"></span>`;
        meta.innerHTML =
          `start=${info.startN}, step(M)=${info.step}, gcd(N,M)=${info.d}, L=${info.L}, edges=${info.edges}, time=${r.animTimeSec.toFixed(1)}s ${sw}`;
      }

      function resetAnim(){
        r.animPlaying = false;
        r.animProgressEdges = 0.0;
        card._setAnimIcon();
      }

      function applyN(){
        const raw = inN.value.trim();
        if (raw === ''){
          r.N = null;
          resetAnim();
          card._updateMeta();
          app.scheduleDraw();
          return;
        }
        const v = Math.floor(Number(raw));
        r.N = Number.isFinite(v) ? v : null;
        if (r.N != null && r.N < 1) r.N = 1;
        inN.value = (r.N == null ? '' : String(r.N));
        resetAnim();
        card._updateMeta();
        app.scheduleDraw();
      }

      function applyM(){
        const raw = inM.value.trim();
        if (raw === ''){
          r.M = null;
          resetAnim();
          card._updateMeta();
          app.scheduleDraw();
          return;
        }
        const v = Math.floor(Number(raw));
        r.M = Number.isFinite(v) ? v : null;
        if (r.M != null && r.M < 1) r.M = 1;
        inM.value = (r.M == null ? '' : String(r.M));
        resetAnim();
        card._updateMeta();
        app.scheduleDraw();
      }

      inN.addEventListener('input', applyN);
      inM.addEventListener('input', applyM);
      inN.addEventListener('change', applyN);
      inM.addEventListener('change', applyM);

      btnAnim.addEventListener('click', ()=>{
        const info = app.getCycleInfo(r);
        const edges = info.edges;

        if (!info.valid || edges <= 0){
          r.animPlaying = false;
          r.animProgressEdges = 0.0;
          card._setAnimIcon();
          app.scheduleDraw();
          return;
        }

        const T = Math.max(0.2, Number(r.animTimeSec) || DEFAULT_ANIM_TIME);
        r.animSpeedEdgesPerSec = edges / T;

        r.animPlaying = !r.animPlaying;
        if (r.animPlaying) r.animProgressEdges = 0.0;
        card._setAnimIcon();

        // rebuild row to reset drawRange
        buildRow3D(r);
        setRowLineProgress(r, r.animPlaying ? 0 : edges);

        app.scheduleDraw();
      });

      btnGear.addEventListener('click', ()=> app.openRowSettings(r, card));

      btnDel.addEventListener('click', ()=>{
        const i = app.rows.findIndex(x => x.id === r.id);
        if (i >= 0){
          clearRow3D(app.rows[i]);
          app.rows.splice(i,1);
        }
        card.remove();
        app.scheduleDraw();
      });

      card._updateMeta = updateMeta;
      card._setAnimIcon = ()=> { btnAnim.textContent = r.animPlaying ? 'â¸' : 'â–¶'; };

      card.appendChild(fieldN);
      card.appendChild(fieldM);
      card.appendChild(btnAnim);
      card.appendChild(btnGear);
      card.appendChild(btnDel);
      card.appendChild(meta);

      updateMeta();
      card._setAnimIcon();
      return card;
    }

    addRow(initial){
      const r = Object.assign(this.newRowDefaults(), initial || {});

      // palette colors by add order
      const idx = this.rows.length;
      const base = palette[idx % palette.length];
      if (!initial || !initial.lineColor) r.lineColor = base;
      if (!initial || !initial.pointColor) r.pointColor = base;

      // validate
      const t = Number(r.animTimeSec);
      r.animTimeSec = (Number.isFinite(t) && t >= 0.2) ? t : DEFAULT_ANIM_TIME;

      const ls = Math.floor(Number(r.labelSizePx));
      r.labelSizePx = (Number.isFinite(ls) && ls >= 8) ? ls : DEFAULT_LABEL_SIZE;

      this.rows.push(r);
      rowsEl.appendChild(this.createRowUI(r));
      this.scheduleDraw();
    }

    openRowSettings(r, card){
      this.modalRow = r;
      this.modalRowCard = card;

      rowModalTitle.textContent = `è¨­å®š ${this.rowTitle(r)}`;

      optVisible.checked = r.visible;
      optShowPoints.checked = r.showPoints;
      optShowLabels.checked = r.showLabels;

      optLabelSize.value = String(r.labelSizePx);

      optLineColor.value = r.lineColor;
      optPointColor.value = r.pointColor;

      optAnimTime.value = String(Number(r.animTimeSec).toFixed(1));
      optStart.value = String(Number.isFinite(r.start) ? r.start : 0);

      rowModalOverlay.style.display = 'flex';
    }

    closeRowSettings(){
      rowModalOverlay.style.display = 'none';
      this.modalRow = null;
      this.modalRowCard = null;
    }

    syncRowModalToRow(){
      if (!this.modalRow) return;
      const r = this.modalRow;

      r.visible = optVisible.checked;
      r.showPoints = optShowPoints.checked;
      r.showLabels = optShowLabels.checked;

      // label size
      {
        const v = Math.floor(Number(optLabelSize.value));
        r.labelSizePx = (Number.isFinite(v) && v >= 8) ? v : DEFAULT_LABEL_SIZE;
        optLabelSize.value = String(r.labelSizePx);
      }

      r.lineColor = optLineColor.value;
      r.pointColor = optPointColor.value;

      // anim time
      {
        const v = Number(optAnimTime.value);
        r.animTimeSec = (Number.isFinite(v) && v >= 0.2) ? v : DEFAULT_ANIM_TIME;
        optAnimTime.value = String(r.animTimeSec.toFixed(1));
      }

      // start int
      {
        const v = Math.floor(Number(optStart.value));
        r.start = Number.isFinite(v) ? v : 0;
        optStart.value = String(r.start);
      }

      // stop anim on change
      r.animPlaying = false;
      r.animProgressEdges = 0.0;

      if (this.modalRowCard && this.modalRowCard._updateMeta) this.modalRowCard._updateMeta();
      if (this.modalRowCard && this.modalRowCard._setAnimIcon) this.modalRowCard._setAnimIcon();

      // rebuild this row only
      buildRow3D(r);

      this.scheduleDraw();
    }

    openGlobalSettings(){
      optCircleColor.value = themeManager.state.circleHex;
      optTheme.value = themeManager.state.theme;
      optRadius.value = String(globalState.radius.toFixed(1));
      optHeight.value = String(globalState.height.toFixed(1));
      globalModalOverlay.style.display = 'flex';
    }

    closeGlobalSettings(){
      globalModalOverlay.style.display = 'none';
    }

    syncGlobalModalToState(){
      themeManager.state.theme = optTheme.value;
      themeManager.state.circleHex = optCircleColor.value;

      const r = Number(optRadius.value);
      globalState.radius = (Number.isFinite(r) && r >= 0.1) ? r : 3.0;

      const h = Number(optHeight.value);
      globalState.height = (Number.isFinite(h) && h >= 0.1) ? h : 4.0;

      // apply theme + rebuild guides
      themeManager.applyTheme(()=>{});
      rebuildGuides();

      // rebuild all rows because geometry depends on R/H
      for (const row of this.rows) buildRow3D(row);

      this.scheduleDraw();
    }
  }

  const app = new App();

  // =========================================================
  // UI events
  // =========================================================
  // row modal close
  rowModalClose.addEventListener('click', ()=> app.closeRowSettings());
  rowModalOverlay.addEventListener('click', (e)=>{ if (e.target === rowModalOverlay) app.closeRowSettings(); });

  [optVisible, optShowPoints, optShowLabels, optLabelSize, optLineColor, optPointColor, optAnimTime, optStart].forEach(el=>{
    el.addEventListener('input', ()=> app.syncRowModalToRow());
    el.addEventListener('change', ()=> app.syncRowModalToRow());
  });

  // global modal
  globalModalClose.addEventListener('click', ()=> app.closeGlobalSettings());
  globalModalOverlay.addEventListener('click', (e)=>{ if (e.target === globalModalOverlay) app.closeGlobalSettings(); });

  optTheme.addEventListener('change', ()=> app.syncGlobalModalToState());
  optCircleColor.addEventListener('input', ()=> app.syncGlobalModalToState());
  optRadius.addEventListener('input', ()=> app.syncGlobalModalToState());
  optHeight.addEventListener('input', ()=> app.syncGlobalModalToState());

  // controls
  btnAdd.addEventListener('click', ()=> app.addRow());

  btnOpenGlobal.addEventListener('click', ()=> app.openGlobalSettings());

  btnSave.addEventListener('click', ()=>{
    // ensure all lines fully drawn in screenshot
    for (const r of app.rows){
      const info = app.getCycleInfo(r);
      if (info.valid && info.edges > 0){
        setRowLineProgress(r, info.edges);
      }
    }
    renderer.render(scene, camera);

    const url = renderer.domElement.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = '3d-string-art.png';
    document.body.appendChild(a);
    a.click();
    a.remove();
  });

  btnReset.addEventListener('click', ()=>{
    // stop animation
    if (app.rafId){
      cancelAnimationFrame(app.rafId);
      app.rafId = null;
      app.lastT = null;
    }

    // clear rows
    for (const r of app.rows) clearRow3D(r);
    app.rows.splice(0, app.rows.length);
    rowsEl.innerHTML = '';
    app.nextId = 1;

    // reset globals
    globalState.radius = 3.0;
    globalState.height = 4.0;
    themeManager.state.theme = 'dark';
    themeManager.state.circleHex = '#b0b0b0';

    themeManager.applyTheme(()=>{});
    rebuildGuides();

    // add one empty row (N/M æœªå…¥åŠ›)
    app.addRow({ N:null, M:null, start:DEFAULT_START, animTimeSec:DEFAULT_ANIM_TIME, labelSizePx: DEFAULT_LABEL_SIZE });

    hud.textContent = "N/M ã‚’å…¥åŠ›ã—ã¦å›³å½¢ã‚’æç”»ã—ã¾ã™ã€‚";

    app.scheduleDraw();
  });

  window.addEventListener('resize', ()=> app.scheduleDraw());

  // =========================================================
  // Render loop (only continuous if needed; we render on demand + while anim)
  // =========================================================
  function loop(){
    // (tick handles animation render; here we keep lightweight)
    requestAnimationFrame(loop);
    // if not animating, nothing special; but camera moves by interaction => render on pointer events already.
    // We still render to keep smooth camera; acceptable minimal.
    renderer.render(scene, camera);
  }

  // =========================================================
  // Boot
  // =========================================================
  function boot(){
    hud.textContent = "N/M ã‚’å…¥åŠ›ã—ã¦å›³å½¢ã‚’æç”»ã—ã¾ã™ã€‚";

    // init global
    themeManager.applyTheme(()=>{});
    rebuildGuides();

    // initial row: empty N/M
    app.addRow({ N:null, M:null, start:DEFAULT_START, animTimeSec:DEFAULT_ANIM_TIME, labelSizePx: DEFAULT_LABEL_SIZE });

    app.scheduleDraw();
    loop();
  }

  // first sizing
  app.resize();
  updateCamera();
  boot();
}
</script>
</body>
</html>
